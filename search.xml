<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[区块链技术栈及学习路线]]></title>
    <url>%2F2018%2F02%2F07%2F%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[仿佛一夜之间，互联网和金融圈都在谈论区块链，而区块链的发展无疑是借着数字货币之浪潮而起，而后被熟知、被认可到如今的大势所趋，目前科技与工业界的共识是区块链将会成为引领第四次工业革命的关键技术，回看2015年火爆的虚拟现实，2016年流行的大数据，2017年独领风骚的人工智能，2018年毫无疑问将会是区块链的元年，可以看到各种新技术的创新迭代正在以前所未有的速度在加快，热门技术的退潮并不是简单的历史更迭，更像是在蓄势引爆一个临界的奇点，有人如此概括：在第四次工业革命中，大数据是生产资料，人工智能是生产力，区块链就是生产关系。如此来看，不管其发展趋势如何，区块链至少是值得我们去学习和了解的。区块链的核心价值在于建立去中心、去信任、不可篡改的分布式应用场景，愿景很美好，但目前该项技术的发展还处在探索的初级阶段，预计3-5年将会大规模增长，未来10年区块链市场将趋于成熟，在区块链时代来临之前，相关技术从业者应当提前做好知识储备，搭上即将来临的顺风车。在此总结了相关学习资料和知识体系图，而目前来看一位合格区块链研发工程师所具备的技术栈应当如下： 一、比特币相关资源1.《比特币白皮书》网址浏览2.【比特币源码下载】，《比特币白皮书下载》3.《精通比特币》讲比特币很详细的一本书，看完基本对比特币的认识就清楚了。4.《TheProof-of-Work Concept》PoW机制理论介绍，英文5.《比特币的原理及运作机制》适合向圈外人介绍什么是比特币什么是区块链。6.《比特币pow难度调节机制》PoW的难度调节是一个要点，一篇简介 二、区块链1.《区块链技术指南》网页在线电子书，对区块链技术讲解得非常全面2.【csdn的blockchain知识库】3.【区块链可应用场景】应用场景探讨，布萌社区下的一篇帖子4.【汪晓明对区块链、以太坊的思考】汪晓明作为朝夕网络CEO，区块链技术的推广者和布道者，参与并制作了区块链视频节目《明说》，向开源技术大牛学习。 三、以太坊1.《以太坊白皮书英文版》2.《以太坊黄皮书》介绍以太坊原理的论文，文长慎入3.【以太坊常见问题】以上三篇都是外文资源4.【Solidity语言】Solidity语言的文档，还是英文。极客学院翻译了一档勉强凑合的doc，http://wiki.jikexueyuan.com/project/solidity-zh/7.《以太坊智能合约编程之菜鸟教程》以太坊中文网站出的8.通过truffle部署以太坊智能合约9.Truffle 3.0部署智能合约至Ethereum节点10.以太坊智能合约编写实例11.以太坊智能合约编写实例212.在CentOS6.5上搭建以太坊私有链 四、Hyperledger fabric1.《Hyperledger Fabric V1.0– 开发者快速入门》万达网络研究中心副总季宙栋写的开发者入门指南，这档知乎专栏可以订阅。2.【Hyperledger 源码分析之 Fabric】源码分析，感兴趣研究的同学可以看看3.【Hyperledgerfablic 1.0 在centos7环境下的安装与部署和动态增加节点】csdn上的一篇技术帖4.【fabric源码搭建】托管在github上的doc说明，纯英文。5.《Hyperledger Fabric1.0架构概览》6.《fabric中文文档》7.【Ubuntu中使用 Docker 部署 HyperledgerFabric】学好docker很重要 五、布萌1.布萌接入指南布萌官方的指南有些模糊，个人整理了一版出来仅供参考2.布萌API文档3.布萌SDK文档两个官方文档，其实官网就有，顺手列在这了：D4.布萌PHP SDK今天看到有朋友放出的PHP的SDK，膜拜大神 六、其他1.《Nodejs开发加密货币》基于Ebookcoin（亿书币）的开发教程，有一定参考价值2.《创建自己的私有比特币测试链》比特币私链搭建教程 最后还谈一下个人感想：现在百度搜一下区块链，培训市场的速成班广告已经占据了头条，计算了一下他们五个月左右的脱产培训班收费是2.5w上下，又是一波红利，而有些培训机构的课程体系，其实只是整合了过去的编程培训内容再添加一点区块链技术就算完事，简直一锅乱炖，这样的学习方式其实会害死人。相比商人的闻风而动，承担教育责任的大学校园却有点不作为，许多大学的计算机课程体系是远远落后的，大部分学生群体也对科技前沿和趋势动向不是很敏感，前些天看到了一篇钛媒体的报道《中国学生狂“吃鸡”，美国学生猛“挖矿”》，学习上的差距可见一斑，不论怎样，学习之事关乎己身，上士闻道勤而行之。 后续将会不断补充相关学习体系，欢迎访问我的博客站点【YitaiCloud】。部分资料参考了这篇入门到放弃，]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>blockChain</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础之数据结构1]]></title>
    <url>%2F2018%2F02%2F07%2Fjava%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[一、基础类型(Primitives)1.基础类型(Primitives)与封装类型(Wrappers)的区别在哪里？1 传递方式不同封装类是引用类型。基本类型（原始数据类型）在传递参数时都是按值传递，而封装类型是按引用传递的(其实“引用也是按值传递的”，传递的是对象的地址)。由于包装类型都是final修饰的不可变量，因此没有提供改变它值的方法，增加了对“按引用传递”的理解难度。int是基本类型，直接存放数值；Integer是类，产生对象时用一个引用指向这个对象。2 封装类可以有方法和属性封装类可以有方法和属性，利用这些方法和属性来处理数据，如Integer.parseInt(Strings)。基本数据类型都是final修饰的，不能继承扩展新的类、新的方法。3 默认值不同基本类型跟封装类型的默认值是不一样的。如int i,i的预设为0；Integer j，j的预设为null,因为封装类产生的是对象，对象默认值为null。4 存储位置基本类型在内存中是存储在栈中，引用类型的引用（值的地址）存储在栈中，而实际的对象（值）是存在堆中。基本数据类型的好处就是速度快（不涉及到对象的构造和回收），封装类的目的主要是更好的处理数据之间的转换。JDK5.0开始可以自动封包了，基本数据类型可以自动封装成封装类。 《 基础类型(Primitives)与封装类型(Wrappers)的区别》 2.简述九种基本数据类型的大小，以及他们的封装类。 3.int和 Integer 哪个会占用更多的内存？int和 Integer 有什么区别？parseInt()函数在什么时候使用到？当然是Integer会占用更多的内存。以下为int和Integer的区别：1、Integer是int的包装类，int则是java的一种基本数据类型2、Integer变量必须实例化后才能使用，而int变量不需要3、Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值4、Integer的默认值是null，int的默认值是0延伸关于Integer和int的比较 ： 由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。 123Integer i = new Integer(100);Integer j = new Integer(100);System.out.print(i == j); //false Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较） 123Integer i = new Integer(100);int j = 100；System.out.print(i == j); //true 非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。（因为非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同） 123Integer i = new Integer(100);Integer j = 100;System.out.print(i == j); //false 对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false 123456Integer i = 100;Integer j = 100;System.out.print(i == j); //trueInteger i = 128;Integer j = 128;System.out.print(i == j); //false 对于第4条的原因：java在编译Integer i = 100 ;时，会翻译成为Integer i = Integer.valueOf(100)；，而java API中对Integer类型的valueOf的定义如下：1234567public static Integer valueOf(int i)&#123; assert IntegerCache.high &gt;= 127; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)&#123; return IntegerCache.cache[i + (-IntegerCache.low)]; &#125; return new Integer(i);&#125; java对于-128到127之间的数，会进行缓存，Integer i = 127时，会将127进行缓存，下次再写Integer j = 127时，就会直接从缓存中取，就不会new了。 《int和Integer的区别》 parseInt()parseInt()将把该字符之前的字符串转换成数字。parseInt()方法还有基模式，可以把二进制、八进制、十六进制或其他任何进制的字符串转换成整数。基是由parseInt()方法的第二个参数指定的，所以要解析十六进制的值，当然，对二进制、八进制，甚至十进制（默认模式），都可以这样调用parseInt()方法。如果十进制数包含前导0，那么最好采用基数10，这样才不会意外地得到八进制的值。12static int parseInt(String s)static int parseInt(String s, int radix) 4.如何去小数四舍五入保留小数点后两位？12//使用银行家算法BigDecimal i = d.multiply(r).setScale(2,RoundingMode.HALF_EVEN); 推荐使用BigDecimal ，并且采用setScale方法来设置精确度，同时使用RoundingMode.HALF_UP表示使用最近数字舍入法则来近似计算。在这里我们可以看出BigDecimal和四舍五入是绝妙的搭配。《java提高篇(三)—–java的四舍五入》 5.char 型变量中能不能存贮一个中文汉字，为什么？char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字，所以char型变量中当然可以存储汉字啦。不过，如果某个特殊的汉字没有被包含在unicode编码字符集中，那么，这个char型变量中就不能存储这个特殊汉字。补充说明：unicode编码占用两个字节，所以，char类型的变量也是占用两个字节。 二、类型转换1.怎样将 bytes 转换为 long 类型12345678910public static long bytes2long(byte[] b) &#123; long temp = 0; long res = 0; for (int i=0;i&lt;8;i++) &#123; res &lt;&lt;= 8; temp = b[i] &amp; 0xff; res |= temp; &#125; return res;&#125; 2.怎么将 byte 转换为 String**123456//string 转成 bytestring s = "Hello!!";byte[] b = new byte[1024*1024];b = System.Text.Encoding.ASCII.GetBytes(s);//当string含有中文字符时用 System.Text.Encoding.UTF8.GetBytes(s);sock.Send(b); 12345//byte 转成 stringbyte[] b1 = new byte[1024*1024*2];sock.Receive(b1);string s1 = System.Text.Encoding.ASCII.GetString(b1);// System.Text.Encoding.UTF8.GetString(b1); 注意： 在把byte数组转换成string的时候，由于byte数组有2M的字节，所以转换后得到的字符串s1也会填充到2M的字符（用\0来填充）所以，为了避免这个问题，可以使用Receive返回的字节数来确定接收到byte的长度123int length = sock.Receive(b1);string s1 = System.Text.Encoding.ASCII.GetString(b1, 0, length);//这样，s1就为byte实际的值 3.如何将数值型字符转换为数字string和int之间的转换 string转换成int : Integer.valueOf(&quot;12&quot;) int转换成string : String.valueOf(12) char转int之间的转换 首先将char转换成stringString str=String.valueOf(&#39;2&#39;)Integer.valueof(str) 或者Integer.PaseInt(str)Integer.valueof返回的是Integer对象，Integer.paseInt返回的是int 4.我们能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象Byte转int1234567public static int bytes2int(byte[] bytes) &#123; int num = bytes[0] &amp; 0xFF; num |= ((bytes[1] &lt;&lt; 8) &amp; 0xFF00); num |= ((bytes[2] &lt;&lt; 16) &amp; 0xFF0000); num |= ((bytes[3] &lt;&lt; 24) &amp; 0xFF000000); return num;&#125; int转 byte12345678public static byte[] int2bytes(int i) &#123; byte[] b = new byte[4]; b[0] = (byte) (0xff&amp;i); b[1] = (byte) ((0xff00&amp;i) &gt;&gt; 8); b[2] = (byte) ((0xff0000&amp;i) &gt;&gt; 16); b[3] = (byte) ((0xff000000&amp;i) &gt;&gt; 24); return b;&#125; 5.能在不进行强制转换的情况下将一个 double 值赋值给 long 类型的变量吗?123456789public static void main(String[] args) &#123; double d = 88.88; long l = Math.round(d); System.out.println(l); long ll = 100L; double dd = (double) ll; System.out.println(dd);&#125; 6.类型向下转换是什么?由低层次类型转换为高层次类型称为向上类型转换。向上类型转换是自动进行的，比如把int型变量赋给为long型变量，把long型变量赋给double型变量，转换都是自动进行的。由派生类转换为基类也是向上提升，也是自动进行的，但转换后，基类的引用符不能应用派生类对象特有的函数。123Human jean = new Human();Vervebrata someone = jean;some.Work(); 运行上面语句会出错，虽然someone指向了一个Human类的对象，但是它不能调用Work()函数，因为someone的类型为Vertebrata，而基类Vertebrata中没有申明Work()函数。要想通过基类引用符someone调用派生类特有的函数，必须将someone的类型强制转换为派生类。这种由基类向派生类转换的过程称为向下类型转换。 三、 数组1.如何权衡是使用无序的数组还是有序的数组在数据偏向查找操作的时候用有序数组快一些，在数据偏向插入的时候，无序数组好一些。删除操作效率一样。 2.怎么判断数组是 null 还是为空（无论使用哪种类型的数组，数组标识符其实只是一个引用，指向在堆中创建的一个真实对象 Int[] A =new int[10];new 一下就是实例化了，开辟了内存空间，基本数据类型的元素会被赋初始值，数组建立后长度不能改变，但是还是可以重新赋值）有如下两个变量定义： 1 int[] zero = new int[0]; 2 int[] nil = null;这两种定义有什么区别呢？zero是一个长度为0的数组，我们称之为“空数组”，空数组也是一个对象，只是包含元素个数为0。nil是一个数组类型的空引用。 3.怎么打印数组？ 怎样打印数组中的重复元素4.Array 和 ArrayList有什么区别？什么时候应该使用Array而不是ArrayList?1）精辟阐述：可以将 ArrayList想象成一种“会自动扩增容量的Array”。2）Array（[]）：最高效；但是其容量固定且无法动态改变； ArrayList： 容量可动态增长；但牺牲效率；3）建议：基于效率和类型检验，应尽可能使用Array，无法确定数组大小时才使用ArrayList！不过当你试着解决更一般化的问题时，Array的功能就可能过于受限。4）Java中一切皆对象，Array也是对象。不论你所使用得Array型别为何，Array名称本身实际上是个reference，指向heap之内得某个实际对象。这个对象可经由“Array初始化语法”被自动产生，也可以以new表达式手动产生。5）Array可做为函数返回值，因为它本身是对象的reference；6）对象数组与基本类型数组在运用上几乎一模一样，唯一差别在于，前者持有得是reference，后者直接持有基本型别之值；例如：12string [] staff=new string[100];int [] num=new int[10]; 7）容器所持有的其实是一个reference指向Object，进而才能存储任意型别。当然这不包括基本型别，因为基本型别并不继承自任何classes。8）面对Array，我们可以直接持有基本型别数值的Array（例如：int [] num;),也可以持有reference（指向对象）的Array；但是容器类仅能持有reference（指向对象），若要将基本型别置于容器内，需要使用wrapper类。但是wrapper类使用起来可能不很容易上手，此外，primitives Array的效率比起“容纳基本型别之外覆类（的reference）”的容器好太多了。当然，如果你的操作对象是基本型别，而且需要在空间不足时自动扩增容量，Array便不适合，此时就得使用外覆类的容器了。9）某些情况下，容器类即使没有转型至原来的型别，仍然可以运作无误。有一种情况尤其特别：编译器对String class提供了一些额外的支持，使它可以平滑运作。10）对数组的一些基本操作，像排序、搜索与比较等是很常见的。因此在Java中提供了Arrays类协助这几个操作：sort(),binarySearch(),equals(),fill(),asList().不过Arrays类没有提供删除方法，而ArrayList中有remove()方法，不知道是否是不需要在Array中做删除等操作的原因（因为此时应该使用链表）。11）ArrayList的使用也很简单：产生ArrayList，利用add()将对象置入，利用get(i）配合索引值将它们取出。这一切就和Array的使用方式完全相同，只不过少了[]而已。 换一种简单说法：1）效率：数组扩容是对ArrayList效率影响比较大的一个因素。每当执行Add、AddRange、Insert、InsertRange等添加元素的方法，都会检查内部数组的容量是否不够了，如果是，它就会以当前容量的两倍来重新构建一个数组，将旧元素Copy到新数组中，然后丢弃旧数组，在这个临界点的扩容操作，应该来说是比较影响效率的。ArrayList是Array的复杂版本ArrayList内部封装了一个Object类型的数组，从一般的意义来说，它和数组没有本质的差别，甚至于ArrayList的许多方法，如Index、IndexOf、Contains、Sort等都是在内部数组的基础上直接调用Array的对应方法。2）类型识别：ArrayList存入对象时，抛弃类型信息，所有对象屏蔽为Object，编译时不检查类型，但是运行时会报错。但是现在有jdk1.5后引入泛型来进行编译检查类型，如错存入了不同类型会直接报错。ArrayList与数组的区别主要就是由于动态增容的效率问题了3）ArrayList可以存任何Object，如String等。 5.数组和链表数据结构描述，各自的时间复杂度数组是将元素在内存中连续存放，由于每个元素占用内存相同，可以通过下标迅速访问数组中任何元素。但是如果要在数组中增加一个元素，需要移动大量元素，在内存中空出一个元素的空间，然后将要增加的元素放在其中。同样的道理，如果想删除一个元素，同样需要移动大量元素去填掉被移动的元素。如果应用需要快速访问数据，很少插入和删除元素，就应该用数组。链表中的元素在内存中不是顺序存储的，而是通过存在元素中的指针联系到一起，每个结点包括两个部分：一个是存储 数据元素的数据域，另一个是存储下一个结点地址的 指针。 如果要访问链表中一个元素，需要从第一个元素开始，一直找到需要的元素位置。但是增加和删除一个元素对于链表数据结构就非常简单了，只要修改元素中的指针就可以了。如果应用需要经常插入和删除元素你就需要用链表。 内存存储区别数组从栈中分配空间, 对于程序员方便快速,但自由度小。链表从堆中分配空间, 自由度大但申请管理比较麻烦. 逻辑结构区别数组必须事先定义固定的长度（元素个数），不能适应数据动态地增减的情况。当数据增加时，可能超出原先定义的元素个数；当数据减少时，造成内存浪费。 链表动态地进行存储分配，可以适应数据动态地增减的情况，且可以方便地插入、删除数据项。（数组中插入、删除数据项时，需要移动其它数据项） 总结1、存取方式上，数组可以顺序存取或者随机存取，而链表只能顺序存取； 2、存储位置上，数组逻辑上相邻的元素在物理存储位置上也相邻，而链表不一定； 3、存储空间上，链表由于带有指针域，存储密度不如数组大； 4、按序号查找时，数组可以随机访问，时间复杂度为O(1)，而链表不支持随机访问，平均需要O(n)； 5、按值查找时，若数组无序，数组和链表时间复杂度均为O(1)，但是当数组有序时，可以采用折半查找将时间复杂度降为O(logn)； 6、插入和删除时，数组平均需要移动n/2个元素，而链表只需修改指针即可； 7、空间分配方面：数组在静态存储分配情形下，存储元素数量受限制，动态存储分配情形下，虽然存储空间可以扩充，但需要移动大量元素，导致操作效率降低，而且如果内存中没有更大块连续存储空间将导致分配失败；链表存储的节点空间只在需要的时候申请分配，只要内存中有空间就可以分配，操作比较灵活高效；数组有没有length()这个方法? String有没有length()这个方法 四、队列1.队列和栈是什么，列出它们的区别队列（Queue）：是限定只能在表的一端进行插入和在另一端进行删除操作的线性表；栈（Stack）：是限定只能在表的一端进行插入和删除操作的线性表。区别如下： 规则不同 1. 队列：先进先出（First In First Out）FIFO 2. 栈：先进后出（First In Last Out ）FILO 对插入和删除操作的限定不同 1. 队列：只能在表的一端进行插入，并在表的另一端进行删除； 2. 栈：只能在表的一端插入和删除。 遍历数据速度不同 1. 队列：基于地址指针进行遍历，而且可以从头部或者尾部进行遍历，但不能同时遍历，无需开辟空间，因为在遍历的过程中不影响数据结构，所以遍历速度要快； 2. 栈：只能从顶部取数据，也就是说最先进入栈底的，需要遍历整个栈才能取出来，而且在遍历数据的同时需要为数据开辟临时空间，保持数据在遍历前的一致性。 2.BlockingQueue是什么 阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。 《聊聊并发（7）Java中的阻塞队列》 3.简述 ConcurrentLinkedQueue LinkedBlockingQueue 的用处和不同之处。 阻塞队列：线程安全按 FIFO（先进先出）排序元素。队列的头部是在队列中时间最长的元素。队列的尾部是在队列中时间最短的元素。新元素插入到队列的尾部，并且队列检索操作会获得位于队列头部的元素。链接队列的吞吐量通常要高于基于数组的队列，但是在大多数并发应用程序中，其可预知的性能要低。注意：1、必须要使用take()方法在获取的时候达成阻塞结果2、使用poll()方法将产生非阻塞效果 非阻塞队列基于链接节点的、无界的、线程安全。此队列按照 FIFO（先进先出）原则对元素进行排序。队列的头部 是队列中时间最长的元素。队列的尾部 是队列中时间最短的元素。新的元素插入到队列的尾部，队列检索操作从队列头部获得元素。当许多线程共享访问一个公共 collection 时，ConcurrentLinkedQueue是一个恰当的选择。此队列不允许 null 元素。 在并发编程中，一般推荐使用阻塞队列，这样实现可以尽量地避免程序出现意外的错误。阻塞队列使用最经典的场景就是socket客户端数据的读取和解析，读取数据的线程不断将数据放入队列，然后解析线程不断从队列取数据解析。还有其他类似的场景，只要符合生产者-消费者模型的都可以使用阻塞队列。使用非阻塞队列，虽然能即时返回结果（消费结果），但必须自行编码解决返回为空的情况处理（以及消费重试等问题）。另外他们都是线程安全的，不用考虑线程同步问题。 《JAVA阻塞队列以及非阻塞队列的区别》 4.ArrayList、Vector、LinkedList的存储性能和特性ArrayList 和Vector他们底层的实现都是一样的，都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢。 Vector中的方法由于添加了synchronized修饰，因此Vector是线程安全的容器，但性能上较ArrayList差，因此已经是Java中的遗留容器。 LinkedList使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。 Vector属于遗留容器（Java早期的版本中提供的容器，除此之外，Hashtable、Dictionary、BitSet、Stack、Properties都是遗留容器），已经不推荐使用，但是由于ArrayList和LinkedListed都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类Collections中的synchronized List方法将其转换成线程安全的容器后再使用（这是对装潢模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现）。 五、String1.ByteBuffer 与 StringBuffer有什么区别六、Collections1.介绍Java中的Collection FrameWork。集合类框架的基本接口有哪些？总共有两大接口：Collection 和Map ，一个元素集合，一个是键值对集合； 其中List和Set接口继承了Collection接口，一个是有序元素集合，一个是无序元素集合； ArrayList和LinkedList实现了List接口，HashSet实现了Set接口，这几个都比较常用； HashMap和HashTable实现了Map接口，并且HashTable是线程安全的，但是HashMap性能更好； 2.Collections类是什么？Collection 和 Collections的区别？Collection、Map的实现.Collection是单列集合 List元素是有序的、可重复。有序的collection，可以对列表中每个元素的插入位置进行精确地控制。可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。 可存放重复元素，元素存取是有序的。 List接口中常用类Vector：线程安全，但速度慢，已被ArrayList替代。底层数据结构是数组结构；ArrayList：线程不安全，查询速度快。底层数据结构是数组结构；LinkedList：线程不安全。增删速度快。底层数据结构是列表结构； Set(集) 元素无序的、不可重复。取出元素的方法只有迭代器。不可以存放重复元素，元素存取是无序的。 Set接口中常用的类HashSet：线程不安全，存取速度快。它是如何保证元素唯一性的呢？依赖的是元素的hashCode方法和euqals方法。TreeSet：线程不安全，可以对Set集合中的元素进行排序。它的排序是如何进行的呢？通过compareTo或者compare方法中的来保证元素的唯一性。元素是以二叉树的形式存放的。 Map 是一个双列集合 Hashtable:线程安全，速度快。底层是哈希表数据结构。是同步的。不允许null作为键，null作为值。 Properties:用于配置文件的定义和操作，使用频率非常高，同时键和值都是字符串。是集合中可以和IO技术相结合的对象。 HashMap:线程不安全，速度慢。底层也是哈希表数据结构。是不同步的。允许null作为键，null作为值。替代了Hashtable. LinkedHashMap: 可以保证HashMap集合有序。存入的顺序和取出的顺序一致。 TreeMap：可以用来对Map集合中的键进行排序. Collection是集合类的上级接口，子接口主要有Set 和List。Collections是针对集合类的一个帮助类，提供了操作集合的工具方法：一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。 《介绍Collection框架的结构；Collection 和 Collections的区别》 3.集合类框架的最佳实践有哪些根据应用的需要合理的选择集合的类型对性能非常重要 假如元素的大小是固定的，而且能事先知道，我们就该用Array而不是ArrayList. 有些集合类允许指定初始容量。因此，如果我们能估计出存储元素的数目，我们可以设置初始容量来避免重新计算hash值或者扩容. 为了类型安全，可读性和健壮性的原因总要使用翻新。同时，使用泛型还能皮面运行时的ClassCastException. 使用JDK提供的不变类（immutable class）作为Map的键可以避免为我们自己的类实现hashCode()和equals()方法。 编程的时候接口优于实现。 底层的集合实际上是空的情况下返回长度是0的集合或者是数组，不要返回null. 4.为什么 Collection 不从 Cloneable 和 Serializable 接口继承?Collection接口指定一组对象，对象即为它的元素。如何维护这些元素由Collection的具体实现决定。例如，一些如List的Collection实现允许重复的元素，而其它的如Set就不允许。很多Collection实现有一个公有的clone方法。然而，把它放到集合的所有实现中也是没有意义的。这是因为Collection是一个抽象表现。重要的是实现，克隆（cloning）或者序列化（serialization）的语义和含义是跟具体的实现相关的。因此应该由集合类的具体实现类来决定如何被克隆或者序列化。 5.说出几点 Java 中使用 Collections 的最佳实践？a）使用正确的集合类，例如，如果不需要同步列表，使用 ArrayList 而不是 Vector。b）优先使用并发集合，而不是对集合进行同步。并发集合提供更好的可扩展性。c）使用接口代表和访问集合，如使用List存储 ArrayList，使用 Map 存储 HashMap 等等。d）使用迭代器来循环集合。e）使用集合的时候使用泛型 6.Collections 中 遗留类 (HashTable、Vector) 和 现有类的区别7.什么是 B+树，B-树，列出实际的使用场景。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础之关键字和操作符]]></title>
    <url>%2F2018%2F02%2F04%2Fjava%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E6%93%8D%E4%BD%9C%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[final,finalize,finally关键字1.finalize和final关键字什么是finalize()方法？finalize()方法什么时候被调用？答： Java允许在类中定义一个名为finalize()的方法，一旦垃圾回收器准备好释放对象占用的存储空间，将首先调用finalize()方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。 析构函数(finalization)的目的是什么析构函数目的是撤销对象前、完成一些清理工作，比如释放资源。释放了之后这些资源可以被回收，重新利用。 final关键字有哪些用法final关键字主要用于修饰类、类成员、方法、以及方法的形参。 final修饰成员属性：说明该成员属性是常量，不能被修改； final修饰类，该类是最终类，不能被继承。 final修饰方法：该方法是最终方法，不能被重写。 final关键字修饰形参：1：当形参被修饰为final,那么该形参所属的方法中不能被篡改。 2. final 与 static 关键字可以用于哪里？它们的作用是什么？用于修饰成员变量和成员方法，可以理解为“全局常量”，对于变量表示一旦给定值就不可以修改，并且通过类名可以访问；对于方法表示不可覆盖，并且可以通过类名直接访问 3. final, finally, finalize的区别（或者说final、finalize 和 finally 的不同之处？）**final关键字可以用于类，方法，变量前，用来表示该关键字修饰的类，方法，变量具有不可变的特性。 final关键字用于基本数据类型前：这时表明该关键字修饰的变量是一个常量，在定义后该变量的值就不能被修改。 final关键字用于方法声明前：这时意味着该方法时最终方法，只能被调用，不能被覆盖，但是可以被重载。 final关键字用于类名前：此时该类被称为最终类，该类不能被其他类继承。 finalize()方法来自于java.lang.Object，用于回收资源。可以为任何一个类添加finalize方法。finalize方法将在垃圾回收器清除对象之前调用。在实际应用中，不要依赖使用该方法回收任何短缺的资源，这是因为很难知道这个方法什么时候被调用。finally，当代码抛出一个异常时，就会终止方法中剩余代码的处理，并退出这个方法的执行。finally块是程序在正常情况下或异常情况下都会运行的。比较适合用于既要处理异常又有资源释放的代码，保证了资源的合理回收。 4. 能否在运行时向 static final 类型的赋值不可以，被static final修饰的变量只能在被定义的时候或者类的静态代码块中初始化，一旦赋值后就不能在改变了。static final相当于类常量，就是在类被加载进内存的时候就要为属性分配内存，static块就是类被加载的时候执行且被执行一次，所以可以在其中进行初始化。 5. 使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变?是引用不能变（final引用恒定不变），引用的对象内容还是可以变的 8. throws, throw分别代表什么意义?throw是指的语句抛出一个异常，throws指的是声明方法可能抛出的异常类型 9、Java 有几种修饰符？分别用来修饰什么类的修饰符： public可以在其他任何类中使用，默认为统一包下的任意类。 abstract抽象类，不能被实例化，可以包含抽象方法，抽象方法没有被实现，无具体功能，只能衍生子类。 final不能被继承。 成员变量 访问修饰符： static类变量：一个类所拥有的变量，不是类的每个实例有的变量。类变量是指不管类创建了多少对象，系统仅在第一次调用类的时候为类变量分配内存，所有对象共享该类的类变量，因此可以通过类本身或者某个对象来访问类变量。 final：常量。 volatile：声明一个可能同时被并存运行的几个线程所控制和修改的变量。 abstract：只有声明部分，方法体为空，具体在子类中完成。 transient：（过度修饰符）指定该变量是系统保留，暂无特别作用的临时性变量。 方法修饰符： 访问修饰符public（公共控制符）private（私有控制符）指定此方法只能有自己类等方法访问，其他的类不能访问（包括子类）protected（保护访问控制符）指定该方法可以被它的类和子类进行访问。 final，指定该方法不能被重载。 static，指定不需要实例化就可以激活的一个方法。 synchronize，同步修饰符，在多个线程中，该修饰符用于在运行前，对他所属的方法加锁，以防止其他线程的访问，运行结束后解锁。 native，本地修饰符。指定此方法的方法体是用其他语言在程序外部编写的。 《java中的访问修饰符》《java中的类修饰符、成员变量修饰符、方法修饰符》 volatile关键字volatile是一个特殊的修饰符，只有成员变量才能使用它。在Java并发程序缺少同步类的情况下，多线程对成员变量的操作对其它线程是透明的。volatile变量可以保证下一个读取操作会在前一个写操作之后发生，就是上一题的volatile变量规则。原理以及底层实现可参考： 《面试必问的 volatile，你了解多少？》《volatile 关键字实现原理》汇编层面的讲解，推荐！ 1、volatile 修饰符的有过什么实践2、volatile 变量是什么？volatile 变量和 atomic 变量有什么不同Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。 3、volatile 类型变量提供什么保证？能使得一个非原子操作变成原子操作吗?volatile只提供了保证访问该变量时，每次都是从内存中读取最新值，并不会使用寄存器缓存该值——每次都会从内存中读取。而对该变量的修改，volatile并不提供原子性的保证。那么编译器究竟是直接修改内存的值，还是使用寄存器修改都符合volatile的定义。所以，一句话，volatile并不提供原子性的保证。 4、能创建 volatile 数组吗？可以，volatile修饰的变量如果是对象或数组之类的，其含义是对象获数组的地址具有可见性，但是数组或对象内部的成员改变不具备可见性 5、transient变量有什么特点? 一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。 transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。 被transient关键字修饰的变量不能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。 6、super什么时候使用?super主要存在于子类方法中，用于指向子类对象中父类对象。1：访问父类的属性2：访问父类的函数3：访问父类的构造函数 7、public static void 写成 static public void会怎样?一样的 8、说明一下public static void main(String args[])这段声明里每个关键字的作用?主函数是什么：主函数是一个特殊的函数，作为程序的入口，可以被jvm识别。主函数的定义： public ：代表该函数的访问权限是最大的。 static ：代表主函数随着类的加载，就已经存在了。 void： 主函数没有具体的返回值 main ： 不是关键字，是一个特殊的单词可以被jvm识别。 (String[] args) 函数的参数，参数类型是一个数组，该数组中的元素是字符串。字符串类型的数组。 主函数的格式是固定的：jvm能够识别 9、sizeof 是Java 的关键字吗?不是，C和C++用sizeof()解决移植问题，java不需要。 static关键字1、static class 与 non static class的区别 内部静态类不需要有指向外部类的引用。但非静态内部类需要持有对外部类的引用。 非静态内部类能够访问外部类的静态和非静态成员。静态类不能访问外部类的非静态成员。他只能访问外部类的静态成员。 一个非静态内部类不能脱离外部类实体被创建，一个非静态内部类可以访问外部类的数据和方法，因为他就在外部类里面。 生命周期（Lifecycle）： 静态方法（Static Method）与静态成员变量一样，属于类本身，在类装载的时候被装载到内存（Memory），不自动进行销毁，会一直存在于内存中，直到JVM关闭。 非静态方法（Non-Static Method）又叫实例化方法，属于实例对象，实例化后才会分配内存，必须通过类的实例来引用。不会常驻内存，当实例对象被JVM 回收之后，也跟着消失。 效率：静态方法的使用效率比非静态方法的效率高。 线程安全 静态方法是共享代码段，静态变量是共享数据段。既然是“共享”就有并发（Concurrence）的问题。 非静态方法是针对确定的一个对象的，所以不会存在线程安全的问题。 静态方法和实例方法是一样的，在类型第一次被使用时加载。调用的速度基本上没有差别。 2、static 关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法，静态类型有什么特点？static表示静态的意思，可用于修饰成员变量和成员函数，被静态修饰的成员函数只能访问静态成员，不可以访问非静态成员。静态是随着类的加载而加载的，因此可以直接用类进行访问。 重写是子类中的方法和子类继承的父类中的方法一样（函数名，参数，参数类型，反回值类型），但是子类中的访问权限要不低于父类中的访问权限。重写的前提是必须要继承，private修饰不支持继承，因此被私有的方法不可以被重写。在Java中，如果父类中含有一个静态方法，且在子类中也含有一个返回类型、方法名、参数列表均与之相同的静态方法，那么该子类实际上只是将父类中的该同名方法进行了隐藏，而非重写。换句话说，父类和子类中含有的其实是两个没有关系的方法，它们的行为也并不具有多态性。 《static方法能否被重写》 3、main() 方法为什么必须是静态的？能不能声明 main() 方法为非静态？用static修饰的就是静态方法。静态方法不依靠对象而存在。其直接与类有关，只要包含在类中，就可以得到执行，而不一定依附于对象的存在而执行。因此，main方法作为程序的入口方法，在这之前是不可能有任何对象被建立的，也就在main之前包括main自身不可能是非静态方法。所以main方法一定是静态的，有类就行——从而得到执行，进而有更多静态或非静态方法得到执行。 4、是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用不可以，静态函数中不能访问非静态成员变量，只能访问静态变量。因为静态优先于对象存在.静态方法中更不可以出现this 5、静态变量在什么时候加载？编译期还是运行期？静态代码块加载的时机呢？静态是随着类的加载而加载的，JVM的代码编译运行顺序是编译、类的加载到执行，属于二者的过渡期。静态代码块也是如此。 6、成员方法是否可以访问静态变量？为什么静态方法不能访问成员变量？成员方法中可以访问静态成员变量。 请看下面代码来确定程序的打印先后顺序：12345678910111213141516171819202122232425public class test &#123; public static void main(String[] args) &#123; new test(); &#125; static int num = 4; &#123; num += 3; System.out.println(b); &#125; int a = 5; &#123; System.out.println(c); &#125; test() &#123;System.out.println(d);&#125; static &#123;System.out.println(a);&#125; static void run() &#123;System.out.println(e);&#125;&#125; 执行顺序如下：1234567891011121314151617181920212223242526272829303132public class test &#123; //1.第一步，准备加载类 public static void main(String[] args) &#123; new test(); //4.第四步，new一个类，但在new之前要处理匿名代码块 &#125; static int num = 4; //2.第二步，静态变量和静态代码块的加载顺序由编写先后决定 &#123; num += 3; System.out.println(b);//5.第五步，按照顺序加载匿名代码块，代码块中有打印 &#125; int a = 5; //6.第六步，按照顺序加载变量 &#123; 成员变量第三个 System.out.println(c); //7.第七步，按照顺序打印c &#125; //如果将构造函数和构造代码块互换，依旧还是先执行构造代码块。 test() &#123; //类的构造函数，第四个加载 System.out.println(d); //8.第八步，最后加载构造函数，完成对象的建立 &#125; static &#123; //3.第三步，静态块，然后执行静态代码块，因为有输出，故打印a System.out.println(a); &#125; static void run() //静态方法，调用的时候才加载 注意看，e没有加载 &#123; System.out.println(e); &#125;&#125; 静态块（静态变量）——成员变量——构造方法——静态方法1、静态代码块（只加载一次） 2、构造方法（创建一个实例就加载一次）3、静态方法需要调用才会执行. 如果类还没有被加载： 1、先执行父类的静态代码块和静态变量初始化，并且静态代码块和静态变量的执行顺序只跟代码中出现的顺序有关。 2、执行子类的静态代码块和静态变量初始化。 3、执行父类的实例变量初始化 4、执行父类的构造函数（有构造代码块则先执行构造代码块） 5、执行子类的实例变量初始化 6、执行子类的构造函数 如果类已经被加载：则静态代码块和静态变量就不用重复执行，再创建类对象时，只执行与实例相关的变量初始化和构造方法。 补充构造代码块：给对象进行初始化。对象一建立就运行并且优先于构造函数。构造代码块和构造函数的区别，构造代码块是给所有对象进行统一初始化， 构造函数给对应的对象初始化。 switch关键字1、switch 语句中的表达式可以是什么类型数据？switch(A),括号中A的取值可以是byte、short、int、char、String，还有枚举类型。 2、switch 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上？ Java 7之前，switch后面的括号里面只能放int类型的值，注意是只能放int类型，但是放byte，short，char类型的也可以，是因为byte，short，shar可以自动提升（自动类型转换）为int，不是说就可以放它们，说白了，你放的byte，short，shar类型，然后他们会自动转换为int类型（宽化，自动转换并且安全），其实最后放的还是int类型。String可以了，但是long仍然不行。 1.小的往大的转换(宽化)，自动转换，有些时候就会自动提升为大的类型，比如switch中2.大的往小的转换(窄化)必须强制类型转换所以long不行，要想行就得强转如（int）long。同理，float、double也是不行的，要想行就强转。 3、while 循环和 do 循环有什么不同？while语法格式：123while(布尔表达式)&#123;//语句&#125; 先判断布尔表达式，如果为true就会执行循环体中的语句，然后再判断布尔表达式，如果为true就执行循环体中的语句，一直到布尔表达式为false，然后循环结束。通常用算术运算符（++ – 累减）do/while语法格式：123do&#123;//语句&#125;while(布尔表达式); 先执行一次循环体，然后在判断布尔表达式是不是true，如果是就继续执行循环体，在判断布尔表达式，直到为false就结束循环。两者的区别：while是先判断在执行如果判断不成立，就不会执行；do/while是先执行在判断，不管判断是否成立都会执行一次 操作符1、&amp;操作符和&amp;&amp;操作符有什么区别&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&amp;&amp;而不是&amp;。 2、a = a + b 与 a += b 的区别？★ =：赋值运算符，在编译器将右边的表达式结果计算出来后，和左边的变量类型比较精度，如果左边的变量精度低于右边的结果的精度，编译器会显式的报错，告诉程序员去强制转型。（若a精度类型弱于b，a = a + b出错，编译检查报错）最后将表达式的结果复制到变量所在的内存区。★ +=：暂且称之为运算符，编译器自动隐式直接将+=运算符后面的操作数强制装换为前面变量的类型，然后在变量所在的内存区上直接根据右边的操作数修改左边变量内存存储的二进制数值最后达到和赋值运算符相同的目的。与前者相比，由于后者是位操作，效率也较前者高。 3、30.1 == 0.3 将会返回什么？true 还是 false？False，类型不一致。 4、float f=3.4; 是否正确？不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成float f =3.4F;。 5、short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？对于short s1 = 1; s1 = s1 + 1;由于1是int类型，因此s1+1运算结果也是int 型，需要强制转换类型才能赋值给short型。而short s1 = 1; s1 += 1;可以正确编译，因为s1+= 1;相当于s1 = (short)(s1 + 1);其中有隐含的强制类型转换。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象编程（OOP）知识点总结]]></title>
    <url>%2F2018%2F02%2F02%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88OOP%EF%BC%89%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一.面向对象的基本概念1.解释下多态性（polymorphism），封装性（encapsulation），内聚（cohesion）以及耦合（coupling）抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。 封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情）。内聚：进行架构设计时的内聚高低是指，设计某个模块或者关注点时，模块或关注点内部的一系列相关功能的相关程度的高低。高内聚提供了更好的可维护性和可复用性。而低内聚的模块则表名模块直接的依赖程度高，那么一旦修改了该模块依赖的对象则无法使用该模块，必须也进行相应的修改才可以继续使用。 耦合：简单地说，软件工程中对象之间的耦合度就是对象之间的依赖性。指导使用和维护对象的主要问题是对象之间的多重依赖性。对象之间的耦合越高，维护成本越高。因此对象的设计应使类和构件之间的耦合最小。耦合性是程序结构中各个模块之间相互关联的度量。它取决于各个模块之间的接口的复杂程度、调用模块的方式以及哪些信息通过接口。 耦合可以分为以下几种，它们之间的耦合度由高到低排列如下： 内容耦合。当一个模块直接修改或操作另一个模块的数据时，或一个模块不通过正常入口而转入另一个模块时，这样的耦合被称为内容耦合。内容耦合是最高程度的耦合，应该避免使用之。 公共耦合。两个或两个以上的模块共同引用一个全局数据项，这种耦合被称为公共耦合。在具有大量公共耦合的结构中，确定究竟是哪个模块给全局变量赋了一个特定的值是十分困难的。 外部耦合 。一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传递该全局变量的信息，则称之为外部耦合。控制耦合 。一个模块通过接口向另一个模块传递一个控制信号，接受信号的模块根据信号值而进行适当的动作，这种耦合被称为控制耦合。标记耦合 。若一个模块A通过接口向两个模块B和C传递一个公共参数，那么称模块B和C之间存在一个标记耦合。 数据耦合。模块之间通过参数来传递数据，那么被称为数据耦合。数据耦合是最低的一种耦合形式，系统中一般都存在这种类型的耦合，因为为了完成一些有意义的功能，往往需要将某些模块的输出数据作为另一些模块的输入数据。 非直接耦合 。两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的。 参考：《面向对象三大特性五大原则 + 低耦合高内聚》 2.多态的用途和实现原理 1、编译时多态（又称静态多态）2、运行时多态（又称动态多态） 重载（overload）就是编译时多态的一个例子，编译时多态在编译时就已经确定，运行时运行的时候调用的是确定的方法。我们通常所说的多态指的都是运行时多态，也就是编译时不确定究竟调用哪个具体方法，一直延迟到运行时才能确定。这也是为什么有时候多态方法又被称为延迟方法的原因。 多态通常有两种实现方法：1、子类继承父类（extends）2、子类实现接口（implements） 多态最大的用途个人认为在于对设计和架构的复用，更进一步来说，《设计模式》中提倡的针对接口编程而不是针对实现编程就是充分利用多态的典型例子。定义功能和组件时定义接口，实现可以留到之后的流程中。同时一个接口可以有多个实现，甚至于完全可以在一个设计中同时使用一个接口的多种实现。 多态实现原理多态允许具体访问时实现方法的动态绑定。Java对于动态绑定的实现主要依赖于方法表，通过继承和接口的多态实现有所不同。继承：在执行某个方法时，在方法区中找到该类的方法表，再确认该方法在方法表中的偏移量，找到该方法后如果被重写则直接调用，否则认为没有重写父类该方法，这时会按照继承关系搜索父类的方法表中该偏移量对应的方法。接口：Java 允许一个类实现多个接口，从某种意义上来说相当于多继承，这样同一个接口的的方法在不同类方法表中的位置就可能不一样了。所以不能通过偏移量的方法，而是通过搜索完整的方法表。tips：因为每次接口调用都要搜索方法表，所以从效率上来说，接口方法的调用总是慢于类方法的调用的。 《Java 多态的实现机制》《Java技术——多态的实现原理》 3.对象封装的原则是什么?在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。要访问该类的代码和数据，必须通过严格的接口控制。封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。 修改属性的可见性来限制对属性的访问（一般限制为private）； 对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问； 4.获得一个类的类对象有哪些方式？ 1.通过对象的getClass方法进行获取。这种方式需要具体的类和该类的对象，以及调用getClass方法。 2.任何数据类型(包括基本数据类型)都具备着一个静态的属性class，通过它可直接获取到该类型对应的Class对象。这种方式要使用具体的类，然后调用类中的静态属性class完成，无需调用方法，性能更好。 3.通过Class.forName()方法获取。这种方式仅需使用类名，就可以获取该类的Class对象，更有利于扩展。1234567891011121314151617181920212223242526272829303132333435363738import org.junit.Test;/** * 演示获取Class c对象的三种方法 *@fileName ReflectGetClass.java */public class ReflectGetClass &#123; /** * 法1：通过对象---对象.getClass()来获取c(一个Class对象) */ @Test public void get1()&#123; Person p=new Person("Jack", 23); Class c=p.getClass();//来自Object方法 &#125; /** * 法2：通过类(类型)---任何数据类型包括(基本数据类型) * 都有一个静态的属性class ，他就是c 一个Class对象 */ @Test public void get2()&#123; Class c=Person.class; Class c2=int.class; &#125; /** * 法3：通过字符串(类全名 )---能够实现解耦：Class.forName(str) */ @Test public void get3()&#123; try &#123; Class c=Class.forName("cn.hncu.reflect.test.Person"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 5.重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？一、重写（override）override是重写（覆盖）了一个方法，以实现不同的功能。一般是用于子类在继承父类时，重写（重新实现）父类中的方法。重写（覆盖）的规则： 1、重写方法的参数列表必须完全与被重写的方法的相同,否则不能称其为重写而是重载. 2、重写方法的访问修饰符一定要大于被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private）。 3、重写的方法的返回值必须和被重写的方法的返回一致； 4、重写的方法所抛出的异常必须和被重写方法的所抛出的异常一致，或者是其子类； 5、被重写的方法不能为private，否则在其子类中只是新定义了一个方法，并没s有对其进行重写。 6、静态方法不能被重写为非静态的方法（会编译出错）。二、overload是重载一般是用于在一个类内实现若干重载的方法，这些方法的名称相同而参数形式不同。重载的规则： 1、在使用重载时只能通过相同的方法名、不同的参数形式实现。不同的参数类型可以是不同的参数类型，不同的参数个数，不同的参数顺序（参数类型必须不一样）； 2、不能通过访问权限、返回类型、抛出的异常进行重载； 3、方法的异常类型和数目不会对重载造成影响；多态的概念比较复杂，有多种意义的多态，一个有趣但不严谨的说法是：继承是子类使用父类的方法，而多态则是父类使用子类的方法。一般，我们使用多态是为了避免在父类里大量重载引起代码臃肿且难于维护。《java编程思想》中很好的回答了不能以返回值来区分重载方法：12void f()&#123; &#125;void f()&#123; return 1; &#125; 假如有int x=f(),这里是可以区分重载方法，但有时候并不需要返回值，只是调用方法，那么像这样的f()就让人无法理解了。 6.说出几条 Java 中方法重载的最佳实践？** a）不要重载这样的方法：一个方法接收 int 参数，而另个方法接收 Integer 参数。 b）不要重载参数数量一致，而只是参数顺序不同的方法。 c）如果重载的方法参数个数多于 5 个，采用可变参数。 二、抽象类和接口1.抽象类和接口的区别 一、相似性 接口和抽象类都不能被实例化，它们都位于继承树的顶端，用于被其他类实现和继承。 接口和抽象类都可以包含抽象方法，实现接口或继承抽象类的普通子类都必须实现这些抽象方法。二、接口和抽象类的区别 接口里只能包含抽象方法，静态方法和默认方法，不能为普通方法提供方法实现，抽象类则完全可以包含普通方法。 接口里只能定义静态常量，不能定义普通成员变量，抽象类里则既可以定义普通成员变量，也可以定义静态常量。 接口不能包含构造器，抽象类可以包含构造器，抽象类里的构造器并不是用于创建对象，而是让其子类调用这些构造器来完成属于抽象类的初始化操作。 接口里不能包含初始化块，但抽象类里完全可以包含初始化块。 一个类最多只能有一个直接父类，包括抽象类，但一个类可以直接实现多个接口，通过实现多个接口可以弥补Java单继承不足。 接口可以继承接口。抽象类可以实现(implements)接口抽象类可继承具体类。抽象类中可以有静态的main方法。 备注：只要明白了接口和抽象类的本质和作用，这些问题都很好回答，你想想，如果你是java语言的设计者，你是否会提供这样的支持，如果不提供的话，有什么理由吗？如果你没有道理不提供，那答案就是肯定的了。只有记住抽象类与普通类的唯一区别就是不能创建实例对象和允许有abstract方法。 2.java接口的基本概念，是否可继承，以及优点？接口（Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合。接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。如果一个类只由抽象方法和全局常量组成，那么这种情况下不会将其定义为一个抽象类。只会定义为一个接口，所以接口严格的来讲属于一个特殊的类，而这个类里面只有抽象方法和全局常量，就连构造方法也没有。 一个接口可以继承多个接口.interface C extends A, B {}是可以的. 一个类可以实现多个接口:class D implements A,B,C{} 但是一个类只能继承一个类,不能继承多个类class B extends A{} 在继承类的同时,也可以继承接口:class E extends D implements A,B,C{}这也正是选择用接口而不是抽象类的原因 3、接口的优点或者说面向接口编程的思想是什么（这里要结合运行时多态更好理解）在系统分析和架构中，分清层次和依赖关系，每个层次不是直接向其上层提供服务（即不是直接实例化在上层中），而是通过定义一组接口，仅向上层暴露其接口功能，上层对于下层仅仅是接口依赖，而不依赖具体类。好处：首先对系统灵活性大有好处。当下层需要改变时，只要接口及接口功能不变，则上层不用做任何修改。甚至可以在不改动上层代码时将下层整个替换掉。接口体现的是一种规范和实现分离的设计哲学，充分利用接口可以极好地降低程序各模块之间的耦合，从而提高系统的可扩展性和可维护性。基于这种原则，通常推荐“面向接口”编程，而不是面向实现类编程，希望通过面向接口编程来降低程序的耦合。总的来说就是：降低程序耦合度，提高系统的可扩展性和维护性。 三、继承1、继承（Inheritance）与聚合（Aggregation）的区别在哪里2、继承和组合之间有什么不同 如果存在一种IS-A的关系（比如Bee“是一个”Insect），并且一个类需要向另一个类暴露所有的方法接口，那么更应该用继承的机制。 如果存在一种HAS-A的关系（比如Bee“有一个”attack功能），那么更应该运用组合。 3、为什么类只能单继承，接口可以多继承首先，类的多继承有缺点：第一，如果一个类继承多个父类，如果父类中的方法名如果相同，那么就会产生歧义。第二，如果父类中的方法同名，子类中没有覆盖，同样会产生上面的错误。但是接口就设计成多继承，是因为接口可以避免上述问题：首先，接口中的只有抽象方法和静态常量。对于一个类实现多个接口的情况和一个接口继承多个接口的情况，因为接口只有抽象方法，具体方法只能由实现接口的类实现（也是因为实现类一定会覆盖接口中的方法），在调用的时候始终只会调用实现类（也就是子类覆盖的方法）的方法（不存在歧义），因此不存在 多继承的第二个缺点；而又因为接口只有静态的常量，但是由于静态变量是在编译期决定调用关系的，即使存在一定的冲突也会在编译时提示出错；而引用静态变量一般直接使用类名或接口名，从而避免产生歧义，因此也不存在多继承的第一个缺点。4、存在两个类，C 继承 B，B 继承 A，能将 B 转换为 C 么？如 C = (C) B不能转换，测试代码报错：Exception in thread &quot;main&quot; java.lang.ClassCastException: interfaceDemo.B cannot be cast to interfaceDemo.C 5、如果类 a 继承类 b，实现接口c，而类 b 和接口 c 中定义了同名变量，请问会出现什么问题 四、泛型1、泛型的存在是用来解决什么问题？首先需要明确泛型的概念，泛型（Generics ）是把类型参数化，运用于类、接口、方法中，可以通过执行泛型类型调用 分配一个类型，将用分配的具体类型替换泛型类型。然后，所分配的类型将用于限制容器内使用的值，这样就无需进行类型转换，还可以在编译时提供更强的类型检查。总结来说就是：（1）消除显示的强制类型转换，提高代码复用（2）提供更强的类型检查，避免运行时的ClassCastException。这个问题产生的背景是针对容器中，基于继承的泛型实现会带来两个问题，请看代码：123456public class ArrayList &#123; public Object get(int i) &#123; ... &#125; public void add(Object o) &#123; ... &#125; ... private Object[] elementData;&#125; 基于继承的泛型实现会带来两个问题：第一个问题是有关get()方法的，我们每次调用get()方法都会返回一个Object对象，每一次都要强制类型转换为我们需要的类型，这样会显得很麻烦；第二个问题是有关add方法的，假如我们往聚合了String对象的ArrayList中加入一个File对象，编译器不会产生任何错误提示，而这不是我们想要的。所以，从Java 5开始，ArrayList在使用时可以加上一个类型参数（type parameter），这个类型参数用来指明ArrayList中的元素类型。类型参数的引入解决了以上提到的两个问题，如以下代码所示：1234ArrayList&lt;String&gt; s = new ArrayList&lt;String&gt;();s.add("abc");String s = s.get(0); //无需进行强制转换s.add(123); //编译错误，只能向其中添加String对象 2、泛型的常用特点？这里其实问的就是泛型在使用过程中遵循的相关规范。类型参数（又称类型变量）用作占位符，指示在运行时为类分配类型。根据需要，可能有一个或多个类型参数，并且可以用于整个类。根据惯例，类型参数是单个大写字母，该字母用于指示所定义的参数类型。下面列出每个用例的标准类型参数：1234567E：元素K：键N：数字T：类型V：值S、U、V 等：多参数情况中的第 2、3、4 个类型? 表示不确定的java类型（无限制通配符类型） 《Java 泛型一览笔录》《深入理解Java之泛型》 五、匿名内部类内部类（nested classes），面向对象程序设计中，可以在一个类的内部定义另一个类。嵌套类分为两种，即静态嵌套类和非静态嵌套类。静态嵌套类使用很少，最重要的是非静态嵌套类，也即是被称作为内部类(inner)。内部类是JAVA语言的主要附加部分。内部类几乎可以处于一个类内部任何位置，可以与实例变量处于同一级，或处于方法之内，甚至是一个表达式的一部分。 1、匿名内部类是否可以继承其它类？是否可以实现接口？使用匿名内部类我们必须要继承一个父类或者实现一个接口，当然也仅能只继承一个父类或者实现一个接口。同时它也是没有class关键字，这是因为匿名内部类是直接使用new来生成一个对象的引用，当然这个引用是隐式的。不可以继承其它类和实现接口。 2、内部类分为几种？ 成员内部类，在一个类（外部类）中直接定义的内部类； 局部内部类，在一个方法（外部类的方法）中定义的内部类; 匿名内部类， 1.成员内部类可以访问它的外部类的所有成员变量和方法，不管是静态的还是非静态的都可以。在外部类里面创建成员内部类的实例：this.new B()；在外部类之外创建内部类的实例：(new Test1()).new B().go();2.局部内部类定义在方法中，比方法的范围还小。是内部类中最少用到的一种类型。像局部变量一样，不能被public,protected, private和static修饰。只能访问方法中定义的final类型的局部变量。方法内部类在方法中定义，所以只能在方法中使用，即只能在方法当中生成方法内部类的实例并且调用其方法。3.匿名内部类没有名字的局部内部类，不使用关键字class, extends, implements, 没有构造方法。什么情况下需要使用匿名内部类？如果满足下面的一些条件，使用匿名内部类是比较合适的： 只用到类的一个实例。 类在定义后马上用到。 类非常小（SUN推荐是在4行代码以下） 给类命名并不会导致你的代码更容易被理解。 在使用匿名内部类时，要记住以下几个原则： 匿名内部类不能有构造方法。 匿名内部类不能定义任何静态成员、方法和类。 匿名内部类不能是public,protected,private,static。 只能创建匿名内部类的一个实例。 一个匿名内部类一定是在new的后面，用其隐含实现一个接口或实现一个类。 因匿名内部类为局部内部类，所以局部内部类的所有限制都对其生效。123456789101112131415161718//实例代码interface innerclass&#123; public void print();&#125;public class Main &#123; public static void main(String[] args) &#123; innerclass i = new innerclass() &#123; @Override public void print() &#123; System.out.println("匿名内部类"); // TODO Auto-generated method stub &#125; &#125;; i.print(); &#125;&#125; 匿名内部类的高频使用场景是在多线程下(灵活使用箭头函数语法糖)：12345678910// Java 8之前：new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println("Before Java8, too much code for too little to do"); &#125;&#125;).start();//Java 8方式：new Thread(() -&gt; System.out.println("In Java8, Lambda expression!!") ).start(); 3、内部类可以引用它的包含类（外部类）的成员吗？内部类可以直接访问外部类的成员属性 4、请说一下 Java 中为什么要引入内部类？还有匿名内部类？ 内部类对象可以访问创建它的对象的实现，包括私有数据； 内部类不为同一包的其他类所见，具有很好的封装性； 使用内部类可以很方便的编写事件驱动程序； 匿名内部类可以方便的定义运行时回调； 内部类可以方便的定义]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
</search>
