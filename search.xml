<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[网络编程之IO、NIO和Netty]]></title>
    <url>%2F2018%2F12%2F28%2Fjava%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B9%8B%E2%80%94%E2%80%94IO%E3%80%81NIO%E5%92%8CNetty%2F</url>
    <content type="text"><![CDATA[一、基本概述IO 一直是编程学习中的核心部分，在这里所说的IO 不仅仅是对文件的操作，还常常应用在网络编程中，比如 Socket 通信、协议服务器等，都是典型的 IO 操作目标，伴随着海量数据增长和分布式系统的发展，IO 的扩展能力则显得十分重要，Java语言提供了强大的IO机制，基于不同的抽象模型和交互方式，总结之可归纳为三种： 传统的 java.io 包，基于流模型实现的BIO 升级的 java.nio 包，构建多路复用的、同步非阻塞 NIO 改造的NIO2，引入了异步非阻塞的AIO 这里面需要区分和澄清几个关键的概念： 区分同步或异步（synchronous/asynchronous）。简单来说，同步是一种可靠的有序运行机制，当我们进行同步操作时，后续的任务是等待当前调用返回，才会进行下一步；而异步则相反，其他任务不需要等待当前调用返回，通常依靠事件、回调等机制来实现任务间次序关系。 区分阻塞与非阻塞（blocking/non-blocking）。在进行阻塞操作时，当前线程会处于阻塞状态，无法从事其他任务，只有当条件就绪才能继续，比如 ServerSocket 新连接建立完毕，或数据读取、写入操作完成；而非阻塞则是不管 IO 操作是否结束，直接返回，相应操作在后台继续处理。 首先介绍一下IO的基础API设计和概念模型： IO 不仅仅是对文件的操作，网络编程中，比如 Socket 通信，都是典型的 IO 操作目标。输入流、输出流（InputStream / OutputStream）是用于读取或写入字节的，例如操作图片文件。 Reader/Writer 则是用于操作字符，增加了字符编解码等功能，适用于类似从文件中读取或者写入文本信息。本质上计算机操作的都是字节，不管是网络通信还是文件读取，Reader/Writer 相当于构建了应用逻辑和原始数据之间的桥梁。BufferedOutputStream 等带缓冲区的实现，可以避免频繁的磁盘读写，进而提高 IO 处理效率。这种设计利用了缓冲区，将批量数据进行一次操作，但在使用中千万别忘了 flush。 很多 IO 工具类都实现了 Closeable 接口，因为需要进行资源的释放，需要利用try-with-resources、 try-finally 等机制保证 FileInputStream 被明确关闭，进而相应文件描述符也会失效，否则将导致资源无法被释放。利用专栏前面的内容提到的 Cleaner 或 finalize 机制作为资源释放的最后把关，也是必要的。 IO的具体介绍请戳：《java基础之IO流（IO篇）》 接下来说NIO： Buffer，高效的数据容器，除了布尔类型，所有原始数据类型都有相应的 Buffer 实现。 Channel，Channel 是操作系统底层的一种抽象，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中，可以通过Socket 获取 Channel，反之亦然。 Selector，是 NIO 实现多路复用的基础，它提供了一种高效的机制，可以检测到注册在，Selector 上的多个 Channel 中，是否有 Channel 处于就绪状态，进而实现了单线程对多Channel 的高效管理。 在 Java 7 中，NIO 有了进一步的改进，也就是 NIO 2，引入了异步非阻塞 IO 方式，也有很多人叫它 AIO（Asynchronous IO）。异步 IO 操作基于事件和回调机制，可以简单理解为，应用操作直接返回，而不会阻塞在那里，当后台处理完成，操作系统会通知相应线程进行后续工作。 NIO的具体介绍请戳：《java进阶之NIO》 二、网络编程应用1. 基于BIO实现IO和NIO具体的应用在哪里，可结合服务器-客户端（B/S）模式来设计一个极简版的web后台，该后台仅仅能够同时服务多个客户端请求即可。这里有三种思路，首先使用java.io 和 java.net 中的同步、阻塞式 API，可以简单实现。 服务端的实现：123456789101112131415161718192021222324252627282930313233343536/** * IO服务端实现 */public class IOServer &#123; public static void main(String[] args) throws Exception &#123; ServerSocket serverSocket = new ServerSocket(8000); // (1) 接收新连接线程 new Thread(() -&gt; &#123; while (true) &#123; try &#123; // (1) 阻塞方法获取新的连接 Socket socket = serverSocket.accept(); // (2) 每一个新的连接都创建一个线程，负责读取数据 new Thread(() -&gt; &#123; try &#123; int len; byte[] data = new byte[1024]; InputStream inputStream = socket.getInputStream(); // (3) 按字节流方式读取数据 while ((len = inputStream.read(data)) != -1) &#123; System.out.println(new String(data, 0, len)); &#125; &#125; catch (IOException e) &#123; &#125; &#125;).start(); &#125; catch (IOException e) &#123; &#125; &#125; &#125;).start(); &#125;&#125; 客户端的实现：1234567891011121314151617181920212223/** * IO客户端 */public class IOClient &#123; public static void main(String[] args) &#123; Executor executor = Executors.newFixedThreadPool(8); Thread thread = new Thread(() -&gt; &#123; try &#123; Socket socket = new Socket("127.0.0.1", 8000); while (true) &#123; try &#123; socket.getOutputStream().write((new Date() + ": hello world").getBytes()); Thread.sleep(2000); &#125; catch (Exception e) &#123; &#125; &#125; &#125; catch (IOException e) &#123; &#125; &#125;); executor.execute(thread); &#125;&#125; BIO模型实现要点是： 服务器端启动 ServerSocket，端口 8000 表示自动绑定一个空闲端口。 调用 accept 方法，阻塞等待客户端连接。 利用 Socket 模拟了一个简单的客户端，只进行连接、读取、打印。 当连接建立后，启动一个单独线程负责回复客户端请求。 这样，一个简单的 Socket 服务器就被实现出来了。但是我们知道 Java 语言目前的线程实现是比较重量级的，启动或者销毁一个线程是有明显开销的，每个线程都有单独的线程栈等结构，需要占用非常明显的内存，所以，每一个 Client 启动一个线程似乎都有些浪费。可以稍微修正一下引入线程池解决线程开销和切换的问题：1234567serverSocket = new ServerSocket(8000);executor = Executors.newFixedThreadPool(8);while (true) &#123; Socket socket = serverSocket.accept(); ... 开启一个IO线程 ... executor.execute(ioThread);&#125; 这样做似乎好了很多，通过一个固定大小的线程池，来负责管理工作线程，避免频繁创建、销毁线程的开销，这是我们构建并发服务的典型方式。这种工作方式，可以参考下图来理解。 如果连接数并不是非常多，只有最多几百个连接的普通应用，这种模式往往可以工作的很好。但是，如果连接数量急剧上升，这种实现方式就无法很好地工作了，因为线程上下文切换开销会在高并发时变得很明显，这是同步阻塞方式的低扩展性劣势。 2. 基于NIO实现NIO 引入的多路复用机制，提供了另外一种思路： 线程资源不受限：NIO编程模型新来一个连接不再创建一个新的线程，把这条连接直接绑定到某个固定的线程，然后这条连接所有的读写都由该线程来负责，把这么多while死循环变成一个死循环，这个死循环由一个线程控制，一条连接来了，不创建一个while死循环去监听是否有数据可读,，直接把这条连接注册到Selector上，然后通过检查Selector批量监测出有数据可读的连接进而读取数据。 线程切换效率提高：线程数量大大降低，线程切换效率因此也大幅度提高。 数据读写是以字节流为单位效率不高：NIO维护一个缓冲区每次从这个缓冲区里面读取一块的数据，数据读写不再以字节为单位，而是以字节块为单位。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class NIOServer &#123; /** * serverSelector负责轮询是否有新的连接,clientSelector负责轮询连接是否有数据可读. * 服务端监测到新的连接不再创建一个新的线程,而是直接将新连接绑定到clientSelector上,这样不用IO模型中1w个while循环在死等 * clientSelector被一个while死循环包裹,如果在某一时刻有多条连接有数据可读通过 clientSelector.select(1)方法轮询出来进而批量处理 * 数据的读写以内存块为单位 * * @param args * @throws IOException */ public static void main(String[] args) throws IOException &#123; Selector serverSelector = Selector.open(); Selector clientSelector = Selector.open(); new Thread(() -&gt; &#123; try &#123; ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); serverSocketChannel.socket().bind(new InetSocketAddress(8000)); serverSocketChannel.configureBlocking(false); serverSocketChannel.register(serverSelector, SelectionKey.OP_ACCEPT); while (true) &#123; // 轮询监测是否有新的连接 if (serverSelector.select(1) &gt; 0) &#123; Set&lt;SelectionKey&gt; selectionKeys = serverSelector.selectedKeys(); Iterator&lt;SelectionKey&gt; keyIterator = selectionKeys.iterator(); while (keyIterator.hasNext()) &#123; SelectionKey selectionKey = keyIterator.next(); if (selectionKey.isAcceptable()) &#123; try &#123; //(1)每来一个新连接不需要创建一个线程而是直接注册到clientSelector SocketChannel socketChannel = ((ServerSocketChannel) selectionKey.channel()).accept(); socketChannel.configureBlocking(false); socketChannel.register(clientSelector, SelectionKey.OP_READ); &#125; finally &#123; keyIterator.remove(); &#125; &#125; &#125; &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;).start(); new Thread(() -&gt; &#123; try &#123; while (true) &#123; // (2)批量轮询是否有哪些连接有数据可读 if (clientSelector.select(1) &gt; 0) &#123; Set&lt;SelectionKey&gt; selectionKeys = serverSelector.selectedKeys(); Iterator&lt;SelectionKey&gt; keyIterator = selectionKeys.iterator(); while (keyIterator.hasNext()) &#123; SelectionKey selectionKey = keyIterator.next(); if (selectionKey.isReadable()) &#123; try &#123; SocketChannel socketChannel = (SocketChannel) selectionKey.channel(); ByteBuffer byteBuffer = ByteBuffer.allocate(1024); //(3)读取数据以块为单位批量读取 socketChannel.read(byteBuffer); byteBuffer.flip(); System.out.println(Charset.defaultCharset().newDecoder().decode(byteBuffer) .toString()); &#125; finally &#123; keyIterator.remove(); selectionKey.interestOps(SelectionKey.OP_READ); &#125; &#125; &#125; &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125;&#125; 首先，通过 Selector.open() 创建一个 Selector，作为类似调度员的角色。然后，创建一个ServerSocketChannel，并且向 Selector 注册，通过指定 SelectionKey.OP_ACCEPT，告诉调度员，它关注的是新的连接请求。注意，为什么要配置非阻塞模式呢？这是因为阻塞模式下，注册操作是不允许的，会抛出 IllegalBlockingModeException 异常。Selector 阻塞在 select 操作，当有 Channel 发生接入请求，就会被唤醒。 IO 都是同步阻塞模式，所以需要多线程以实现多任务处理。而NIO 则是利用了单线程轮询事件的机制，通过高效地定位就绪的 Channel，来决定做什么，仅仅 select 阶段是阻塞的，可以有效避免大量客户端连接时，频繁线程切换带来的问题，应用的扩展能力有了非常大的提高。下面这张图对这种实现思路进行了形象地说明。 在 Java 7 引入的 NIO 2 中，又增添了一种额外的异步 IO 模式，利用事件和回调，处理Accept、Read 等操作。 AIO 实现看起来是类似这样子：12345678910111213AsynchronousServerSocketChannel serverSock = AsynchronousServerSocketChannel.open().bind(sockAddr);serverSock.accept(serverSock, new CompletionHandler&lt;&gt;() &#123; //为异步操作指定 CompletionHandler 回调函数 @Override public void completed(AsynchronousSocketChannel sockChannel, AsynchronousServerSocketChannel serverSock) &#123; serverSock.accept(serverSock, this); // 另外一个 write（sock，CompletionHandler&#123;&#125;） sayHelloWorld(sockChannel, Charset.defaultCharset().encode ("Hello World!")); &#125; // 省略其他路径处理方法...&#125;); 3.基于Netty实现JDK 的 NIO 编程需要了解很多的概念，编程复杂，对 NIO 入门非常不友好，编程模型不友好，ByteBuffer 的 Api 难以掌握，而且JDK 的 NIO 底层由 epoll 实现，该实现饱受诟病的空轮询 bug 会导致 cpu 飙升 100%。而Netty 封装了 JDK 的 NIO，API开箱即用，对开发友好，用netty来实现将比NIO方是简化了很多： Netty实现服务端：必须要指定三类属性，分别是线程模型、IO模型、连接读写处理逻辑。Netty服务端启动流程：1. 创建引导类，2. 指定线程模型、IO模型、连接读写处理逻辑，3. 绑定端口。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class NettyServer &#123; private static final int BEGIN_PORT = 8000; public static void main(String[] args) &#123; //指定线程模型 NioEventLoopGroup boosGroup = new NioEventLoopGroup(); NioEventLoopGroup workerGroup = new NioEventLoopGroup(); //引导类，负责服务端的启动 final ServerBootstrap serverBootstrap = new ServerBootstrap(); // final AttributeKey&lt;Object&gt; clientKey = AttributeKey.newInstance("clientKey"); serverBootstrap .group(boosGroup, workerGroup) //配置线程组，初始化引导类的线程模型 .channel(NioServerSocketChannel.class) //指定IO模型 .attr(AttributeKey.newInstance("serverName"), "nettyServer") //自定义属性 .childAttr(clientKey, "clientValue") .option(ChannelOption.SO_BACKLOG, 1024) //表示系统用于临时存放已完成三次握手的请求的队列的最大长度，如果连接建立频繁，服务器处理创建新连接较慢，可以适当调大这个参数 .childOption(ChannelOption.SO_KEEPALIVE, true) //开启TCP底层心跳机制 .childOption(ChannelOption.TCP_NODELAY, true) //开Nagle算法,要求高实时性，有数据发送时就马上发送，就关闭，如果需要减少发送次数减少网络交互，就开启。 .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123; @Override protected void initChannel(NioSocketChannel ch) &#123; System.out.println(ch.attr(clientKey).get()); ch.pipeline().addLast(new FirstServerHandler()); &#125; &#125;); //异步方法，调用之后立即返回 bind(serverBootstrap, BEGIN_PORT); &#125; //自动banding递增端口 private static void bind(final ServerBootstrap serverBootstrap, final int port) &#123; serverBootstrap.bind(port).addListener(future -&gt; &#123; if (future.isSuccess()) &#123; System.out.println("端口[" + port + "]绑定成功!"); &#125; else &#123; System.err.println("端口[" + port + "]绑定失败!"); bind(serverBootstrap, port + 1); &#125; &#125;); &#125;&#125; 服务端Handler处理类：12345678910111213141516171819202122232425public class FirstServerHandler extends ChannelInboundHandlerAdapter &#123; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) &#123; ByteBuf byteBuf = (ByteBuf) msg; System.out.println(new Date() + ": 服务端读到数据 -&gt; " + byteBuf.toString(Charset.forName("utf-8"))); // 回复数据到客户端 System.out.println(new Date() + ": 服务端写出数据"); ByteBuf out = getByteBuf(ctx); out.capacity(); ctx.channel().writeAndFlush(out); &#125; private ByteBuf getByteBuf(ChannelHandlerContext ctx) &#123; byte[] bytes = "Hello,Clinet!".getBytes(Charset.forName("utf-8")); ByteBuf buffer = ctx.alloc().buffer(); buffer.writeBytes(bytes); return buffer; &#125;&#125; 客户端启动流程：要启动Netty客户端，必须要指定三类属性，分别是线程模型、IO模型、连接读写处理逻辑。Netty客户端启动流程：1. 创建引导类，2. 指定线程模型、IO模型、连接读写处理逻辑，3. 建立连接。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class NettyClient &#123; private static final int MAX_RETRY = 5; private static final String HOST = "127.0.0.1"; private static final int PORT = 8000; public static void main(String[] args) &#123; NioEventLoopGroup workerGroup = new NioEventLoopGroup(); Bootstrap bootstrap = new Bootstrap(); bootstrap // 1.指定线程模型 .group(workerGroup) // 2.指定 IO 类型为 NIO .channel(NioSocketChannel.class) // 绑定自定义属性到 channel .attr(AttributeKey.newInstance("clientName"), "nettyClient") // 设置TCP底层属性 .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000) .option(ChannelOption.SO_KEEPALIVE, true) .option(ChannelOption.TCP_NODELAY, true) // 3.IO 处理逻辑 .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override public void initChannel(SocketChannel ch) &#123; ch.pipeline().addLast(new FirstClientHandler()); &#125; &#125;); // 4.建立连接 connect(bootstrap, HOST, PORT, MAX_RETRY); &#125; private static void connect(Bootstrap bootstrap, String host, int port, int retry) &#123; bootstrap.connect(host, port).addListener(future -&gt; &#123; if (future.isSuccess()) &#123; System.out.println("连接成功!"); &#125; else if (retry == 0) &#123; System.err.println("重试次数已用完，放弃连接！"); &#125; else &#123; // 第几次重连 int order = (MAX_RETRY - retry) + 1; // 本次重连的间隔 int delay = 1 &lt;&lt; order; System.err.println(new Date() + ": 连接失败，第" + order + "次重连……"); bootstrap.config().group().schedule(() -&gt; connect(bootstrap, host, port, retry - 1), delay, TimeUnit.SECONDS); &#125; &#125;); &#125;&#125; 客户端Handler类：12345678910111213141516171819202122232425262728public class FirstClientHandler extends ChannelInboundHandlerAdapter &#123; @Override public void channelActive(ChannelHandlerContext ctx) &#123; System.out.println(new Date() + ": 客户端写出数据"); // 1.获取数据 ByteBuf buffer = getByteBuf(ctx); // 2.写数据 ctx.channel().writeAndFlush(buffer); &#125; private ByteBuf getByteBuf(ChannelHandlerContext ctx) &#123; byte[] bytes = "Hello,Server!".getBytes(Charset.forName("utf-8")); ByteBuf buffer = ctx.alloc().buffer(); buffer.writeBytes(bytes); return buffer; &#125; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) &#123; ByteBuf byteBuf = (ByteBuf) msg; System.out.println(new Date() + ": 客户端读到数据 -&gt; " + byteBuf.toString(Charset.forName("utf-8"))); &#125;&#125; Netty采用Reactor线程模型。这里面主要有三种Reactor线程模型。分别是单线程模式、主从Reactor模式、多Reactor线程模式。其都可以通过初始和EventLoopGroup进行设置。其主要区别在于，单Reactor模式就是一个线程，既进程处理连接，也处理IO。类似于我们传统的OIO编程。主从Reactor模式，其实就是将监听连接和处理IO的分开在不同的线程完成。最后，主从Reactor线程模型，为了解决多Reactor模型下单一线程性能不足的问题。改为了一组线程池进行处理。官方默认的是采用这种主从Reactor模型。其线程数默认为CPU内核的2倍。 读完可以思考： 基础 API 功能与设计， InputStream/OutputStream 和 Reader/Writer 的关系和区别。 NIO、NIO 2 的基本组成。 给定场景，分别用不同模型实现，分析 BIO、NIO 等模式的设计和实现原理。 NIO 提供的高性能数据操作方式是基于什么原理，如何使用？ 从开发者的角度来看， NIO 自身实现存在哪些问题？有什么改进的想法吗？]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>Interview</tag>
        <tag>NIO</tag>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NIO的基础总结]]></title>
    <url>%2F2018%2F10%2F12%2Fjava%E8%BF%9B%E9%98%B6%E4%B9%8BNIO%2F</url>
    <content type="text"><![CDATA[Java NIO(New IO)是一个可以替代标准Java IO API的IO API（从Java 1.4开始)，Java NIO提供了与标准IO不同的IO工作方式。Java NIO: Channels and Buffers（通道和缓冲区）标准的IO基于字节流和字符流进行操作的，而NIO是基于通道（Channel）和缓冲区（Buffer）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。 Java NIO: Non-blocking IO（非阻塞IO）Java NIO可以让你非阻塞的使用IO，例如：当线程从通道读取数据到缓冲区时，线程还是可以进行其他事情。当数据被写入到缓冲区时，线程可以继续处理它。从缓冲区写入通道也类似。 Java NIO: Selectors（选择器）Java NIO引入了选择器的概念，选择器用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个的线程可以监听多个数据通道。 Java NIO 由以下几个核心部分组成： Channels Buffers Selectors 基本上，所有的 IO 在NIO 中都从一个Channel 开始。Channel 有点象流。 数据可以从Channel读到Buffer中，也可以从Buffer 写到Channel中。 Channel通道涵盖了UDP 和 TCP 网络IO，以及文件IO1234FileChannelDatagramChannelSocketChannelServerSocketChannel Buffer实现，覆盖了能通过IO发送的基本数据类型：byte, short, int, long, float, double 和 char。1234567ByteBufferCharBufferDoubleBufferFloatBufferIntBufferLongBufferShortBuffer Selector允许单线程处理多个 Channel。如果你的应用打开了多个连接（通道），但每个连接的流量都很低，使用Selector就会很方便。例如，在一个聊天服务器中。 一、NIO的使用1.ChannelFileChannel 从文件中读写数据。DatagramChannel能通过UDP读写网络中的数据。SocketChannel 能通过TCP读写网络中的数据。ServerSocketChannel可以监听新进来的TCP连接，像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel。 使用FileChannel读取数据到Buffer中的示例：12345678910111213141516171819RandomAccessFile aFile = new RandomAccessFile("data/nio-data.txt", "rw");FileChannel inChannel = aFile.getChannel();ByteBuffer buf = ByteBuffer.allocate(48);int bytesRead = inChannel.read(buf);while (bytesRead != -1) &#123; System.out.println("Read " + bytesRead); buf.flip(); while(buf.hasRemaining())&#123; System.out.print((char) buf.get()); &#125; buf.clear(); bytesRead = inChannel.read(buf);&#125;aFile.close(); 2.Buffer的使用使用Buffer一般遵循下面几个步骤： 分配空间（ByteBuffer buf = ByteBuffer.allocate(1024); 还有一种allocateDirector） 写入数据到Buffer(int bytesRead = fileChannel.read(buf);) 调用filp()方法（ buf.flip();） 从Buffer中读取数据（System.out.print((char)buf.get());） 调用clear()方法或者compact()方法 Buffer顾名思义：缓冲区，实际上是一个容器，一个连续数组。Channel提供从文件、网络读取数据的渠道，但是读写的数据都必须经过Buffer。如下图： 向Buffer中写数据： 从Channel写到Buffer (fileChannel.read(buf)) 通过Buffer的put()方法 （buf.put(…)） 从Buffer中读取数据： 从Buffer读取到Channel (channel.write(buf)) 使用get()方法从Buffer中读取数据 （buf.get()） 可以把Buffer简单地理解为一组基本数据类型的元素列表，它通过几个变量来保存这个数据的当前位置状态：capacity, position, limit, mark 3.SelectorSelector的创建：1Selector selector = Selector.open(); 为了将Channel和Selector配合使用，必须将Channel注册到Selector上，通过SelectableChannel.register()方法来实现：1234ssc= ServerSocketChannel.open();ssc.socket().bind(new InetSocketAddress(PORT));ssc.configureBlocking(false);ssc.register(selector, SelectionKey.OP_ACCEPT); 《Java NIO 系列教程》《攻破JAVA NIO技术壁垒》]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>IO</tag>
        <tag>NIO</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单说说HTTP协议]]></title>
    <url>%2F2018%2F10%2F12%2Fjava%20web%E5%9F%BA%E7%A1%80%E7%AF%87%E2%80%94%E2%80%94Http%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[一、Http协议HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从3W服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。HTTP是一个应用层协议，基于请求与响应模式的、无状态的、应用层的协议，常基于TCP的连接方式。HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息URL，全称是UniformResourceLocator, 中文叫统一资源定位符,是互联网上用来标识某一处资源的地址。HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。以下是 HTTP 请求/响应的步骤： 1、客户端连接到Web服务器一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，https://www.jianshu.com/yitaicloud。 2、发送HTTP请求通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。 3、服务器接受请求并返回HTTP响应Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。 4、释放连接TCP连接若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求; 5、客户端浏览器解析HTML内容客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。 例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;5、释放 TCP连接;6、浏览器将该 html 文本并显示内容; 《关于HTTP协议，一篇就够了》 如果TCP有点生疏了，请戳下这里 1.常用的HTTP方法有哪些？GET： 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器。POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。PUT： 传输文件，报文主体中包含文件内容，保存到对应URI位置。DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。HEAD： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。OPTIONS：查询相应URI支持的HTTP方法。 2.GET方法与POST方法的区别区别一：get重点在从服务器上获取资源，post重点在向服务器发送数据；区别二： get传输数据是通过URL请求，以field（字段）= value的形式，置于URL后，并用”?”连接，多个请求数据间用”&amp;”连接，如http://127.0.0.1/Test/login.action?name=admin&amp;password=admin，这个过程用户是可见的； post传输数据通过Http的post机制，将字段与对应值封存在请求实体中发送给服务器，这个过程对用户是不可见的； 区别三：Get传输的数据量小，因为受URL长度限制，但效率较高；Post可以传输大量数据，所以上传文件时只能用Post方式；区别四：get是不安全的，因为URL是可见的，可能会泄露私密信息，如密码等(页面可以被缓存，或者获得历史访问记录)；post较get安全性较高；区别五：get方式只能支持ASCII字符，向服务器传的中文字符可能会乱码。post支持标准字符集，可以正确传递中文字符。 3.HTTP请求报文与响应报文格式请求报文包含三部分：a、请求行：包含请求方法、URI、HTTP版本信息b、请求首部字段c、请求内容实体响应报文包含三部分：a、状态行：包含HTTP版本、状态码、状态码的原因短语b、响应首部字段c、响应内容实体 返回的状态1xx：指示信息–表示请求已接收，继续处理2xx：成功–表示请求已被成功接收、理解、接受3xx：重定向–要完成请求必须进行更进一步的操作4xx：客户端错误–请求有语法错误或请求无法实现5xx：服务器端错误–服务器未能实现合法的请求 200：请求被正常处理204：请求被受理但没有资源可以返回206：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。301：永久性重定向302：临时重定向303：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上304：发送附带条件的请求时，条件不满足时返回，与重定向无关307：临时重定向，与302类似，只是强制要求使用POST方法400：请求报文语法有误，服务器无法识别401：请求需要认证403：请求的对应资源禁止被访问404：服务器无法找到对应资源500：服务器内部错误503：服务器正忙 4.常见HTTP首部字段 a、通用首部字段（请求报文与响应报文都会使用的首部字段）Date：创建报文时间Connection：连接的管理Cache-Control：缓存的控制Transfer-Encoding：报文主体的传输编码方式 b、请求首部字段（请求报文会使用的首部字段）Host：请求资源所在服务器Accept：可处理的媒体类型Accept-Charset：可接收的字符集Accept-Encoding：可接受的内容编码Accept-Language：可接受的自然语言 c、响应首部字段（响应报文会使用的首部字段）Accept-Ranges：可接受的字节范围Location：令客户端重新定向到的URIServer：HTTP服务器的安装信息 d、实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）Allow：资源可支持的HTTP方法Content-Type：实体主类的类型Content-Encoding：实体主体适用的编码方式Content-Language：实体主体的自然语言Content-Length：实体主体的的字节数Content-Range：实体主体的位置范围，一般用于发出部分请求时使用 5.HTTP1.1版本新特性先上答案，然后再后面详细解释：a、默认持久连接，节省通信量，只要客户端服务端任意一端没有明确提出断开TCP连接，就一直保持连接，可以发送多次HTTP请求b、管线化，客户端可以同时发出多个HTTP请求，而不用一个个等待响应c、断点续传原理 HTTP 1.1支持持久连接，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。一个包含有许多图像的网页文件的多个请求和应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连接。HTTP 1.1还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。基于HTTP 1.1协议的客户机与服务器的信息交换过程。 【HTTP 1.1与HTTP 1.0的比较HTTP 1.1与HTTP 1.0的比较】 6.HTTP的缺点与HTTPSa、通信使用明文不加密，内容可能被窃听b、不验证通信方身份，可能遭到伪装c、无法验证报文完整性，可能被篡改HTTPS就是HTTP加上加密处理（一般是SSL安全通信线路）+认证+完整性保护 7.HTTP优化利用负载均衡优化和加速HTTP应用利用HTTP Cache来优化网站 补充一点Cache的细节：缓存是一个到处都存在的用空间换时间的例子。通过使用多余的空间，我们能够获取更快的速度。用户在浏览网站的时候，浏览器能够在本地保存网站中的图片或者其他文件的副本，这样用户再次访问该网站的时候，浏览器就不用再下载全部的文件，减少了下载量意味着提高了页面加载的速度。缓存非常有用，但是也带来了一定的缺陷。当我们的网站发生了更新的时候，比如说Logo换了，浏览器本地仍保存着旧版本的Logo，那么浏览器如何来确定使用本地文件还是使用服务器上的新文件？下面来介绍几种判断的方法。 Caching Method 1：Last-Modified服务器为了通知浏览器当前文件的版本，会发送一个上次修改时间的标签，例如：Last-modified: Fri, 16 Mar 2007 04:00:25 GMT Caching Method 2: ETag通常情况下，通过修改时间来比较文件是可行的。但是在一些特殊情况，例如服务器的时钟发生了错误，服务器时钟进行修改，夏时制DST到来后服务器时间没有及时更新，这些都会引起通过修改时间比较文件版本的问题。ETag可以用来解决这种问题。ETag是一个文件的唯一标志符。就像一个哈希或者指纹，每个文件都有一个单独的标志，只要这个文件发生了改变，这个标志就会发生变化。如同 Last-modified 一样，ETag 解决了文件版本比较的问题。只不过 ETag 的级别比 Last-Modified 高一些。 Caching Method 3：Expires缓存一个文件，并且与服务器确认版本的方式非常好，但是仍有一个缺点，我们必须连接服务器。每次使用前都进行一次比较，这种方法很安全，但还不是最好的。我们可以使用 Expiration Date 来减少这种请求。 Caching Method 4：Max-ageExpires的方法很好，但是我们每次都得算一个精确的时间。max-age 标签可以让我们更加容易的处理过期时间。我们只需要说，这份资料你只能用一个星期就可以了。 【利用HTTP Cache来优化网站】 8.跨域问题浏览器的同源策略会导致跨域，这里同源策略又分为以下两种 DOM同源策略：禁止对不同源页面DOM进行操作。这里主要场景是iframe跨域的情况，不同域名的iframe是限制互相访问的。 XmlHttpRequest同源策略：禁止使用XHR对象向不同源的服务器地址发起HTTP请求。 只要协议、域名、端口有任何一个不同，都被当作是不同的域，之间的请求就是跨域操作。要解决跨域问题可以参考以下文章： 《跨域的那些事儿》《跨域资源共享 CORS 详解》 阮一峰大神的精品 另外玉刚写了一篇不错的，角度是站在前端来看的《HTTP 必知必会的那些》]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>HTTP协议</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一致性哈希算法原理和实现]]></title>
    <url>%2F2018%2F05%2F20%2F%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[在做服务器负载均衡时候可供选择的算法有很多，包括： 轮循算法（Round Robin）、哈希算法（HASH）、最少连接算法（Least Connection）、响应速度算法（Response Time）、加权法（Weighted ）等。其中哈希算法是最为常用的算法，比如在nginx+ats / haproxy+squid等CDN架构中，nginx/haproxy所使用的负载均衡算法便是一致性哈希。不仅如此在分布式系统中哈希算法也得到了广泛应用，研究过memcached缓存数据库的人都知道，memcached服务器端本身不提供分布式cache的一致性，而是由客户端来提供，使用一致性哈希的好处在于，增减集群的缓存服务器时，只有少量的缓存会失效，回源量较小。 1.问题的背景假设一个分布式任务调度系统（负载均衡、分布式缓存服务器的常见该场景），执行任务的节点有n台机器，现有m个job在这n台机器上运行，这m个Job需要逐一映射到n个节点中一个，这时候可以选择一种简单的Hash算法来让m个Job可以均匀分布到n个节点中，比如:1hash(Job) % n 替换成分布式Cache也一样的有上述场景：有n个 cache 服务器（后面简称 cache ），那么如何将一个对象 object 映射到n个 cache 上呢上面的公式看上去很完美，但考虑如下两种情形： n个节点中有一个宕掉了，这时候节点数量变更为n-1，此时的映射公式变成 hash(Job) % (n-1) 由于Job数量增加，需要新增机器，此时的映射公式变成 hash(Job) % (n+1) 两种情形可以看到，基本上所有的Job会被重新分配到跟节点变动前不同的节点上，意味着需要迁移几乎所有正在运行的Job，想想这样会给系统带来多大的复杂性和性能损耗。缓存失效相当于少了一个调节池，对于服务器而言也是一场灾难，洪水般的访问都会直接冲向后台服务器；再来考虑第三个问题，由于硬件能力越来越强，你可能想让后面添加的节点多做点活，显然上面的 hash 算法也做不到。有什么方法可以改变这个状况呢，一致性哈希的解决方案就出来了，它用于尽可能地降低节点变动带来的数据迁移开销。 2.一致性Hash性质考虑到分布式系统每个节点都有可能失效，并且新的节点很可能动态的增加进来，如何保证当系统的节点数目发生变化时仍然能够对外提供良好的服务，这是值得考虑的，尤其实在设计分布式缓存系统时，如果某台服务器失效，对于整个系统来说如果不采用合适的算法来保证一致性，那么缓存于系统中的所有数据都可能会失效（即由于系统节点数目发生动态变化时，客户端在请求某一对象时需要重新计算其hash值，由于hash值已经改变，所以很可能找不到保存该对象的服务器节点），因此一致性hash就显得至关重要，良好的分布式cahce系统中的一致性hash算法应该满足以下几个方面： 平衡性(Balance)平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。 单调性(Monotonicity)该性质是最需要考量的因素，单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲区加入到系统中，那么哈希的结果应能够保证原有已分配的内容可以被映射到新的缓冲区中去，而不会被映射到旧的缓冲集合中的其他缓冲区（简单理解：增加新节点，原有的部分内容可以映射过来）。简单的哈希算法往往不能满足单调性的要求，哈希结果的变化意味着当缓冲空间发生变化时，所有的映射关系需要在系统内全部更新，因此会带来极大计算和传输负荷。 分散性(Spread)好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。 负载(Load)负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。 平滑性(Smoothness)平滑性是指缓存服务器的数目平滑改变和缓存对象的平滑改变是一致的。 参考： 一致性哈希算法原理 3.一致性哈希算法原理一致性哈希将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数H的值空间为0 ~ 2^32^-1（即哈希值是一个32位无符号整形），整个空间按顺时针方向组织，0和2^32^-1在零点中方向重合，整个哈希空间环如下： 下一步将各个服务器使用Hash进行一个哈希，具体可以选择服务器的ip或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置，这里假设将上文中四台服务器使用ip地址哈希后在环空间的位置如下： 接下来使用如下算法定位数据访问到相应服务器：将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器。例如有Object A、Object B、Object C、Object D四个数据对象，经过哈希计算后，在环空间上的位置如下： 根据一致性哈希算法，数据A会被定为到Node A上，B被定为到Node B上，C被定为到Node C上，D被定为到Node D上。 下面分析一致性哈希算法的容错性和可扩展性。现假设Node C不幸宕机，可以看到此时对象A、B、D不会受到影响，只有C对象被重定位到Node D。一般的，在一致性哈希算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响。下面考虑另外一种情况，如果在系统中增加一台服务器Node X，如下图所示： 此时对象Object A、B、D不受影响，只有对象C需要重定位到新的Node X 。一般的，在一致性哈希算法中，如果增加一台服务器，则受影响的数据仅仅是新服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它数据也不会受到影响。 综上所述，一致性哈希算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。另外，一致性哈希算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜问题。例如系统中只有两台服务器，其环分布如下: 此时必然造成大量数据集中到Node A上，而只有极少量会定位到Node B上。为了解决这种数据倾斜问题，一致性哈希算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以在服务器ip或主机名的后面增加编号来实现。例如上面的情况，可以为每台服务器计算三个虚拟节点，于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点： 4.一致性Hash的java实现1.确定哈希值空间考虑通常的 hash 算法都是将 value 映射到一个 32 为的 key 值，也即是 0~2^32^-1 次方的数值空间 2.计算节点哈希将节点Node向这个值空间映射，取Node的Hash值，选取一个可以固定标识一个Node的属性值进行Hashing，假设以字符串形式输入，可以取Node标识的md5值，然后截取其中32位作为映射值。md5取值如下：1234567891011121314151617private byte[] md5(String value) &#123; MessageDigest md5; try &#123; md5 = MessageDigest.getInstance("MD5"); &#125; catch (NoSuchAlgorithmException e) &#123; throw new IllegalStateException(e.getMessage(), e); &#125; md5.reset(); byte[] bytes; try &#123; bytes = value.getBytes("UTF-8"); &#125; catch (UnsupportedEncodingException e) &#123; throw new IllegalStateException(e.getMessage(), e); &#125; md5.update(bytes); return md5.digest();&#125; 因为映射值只需要32位即可，所以可以利用以下方式计算最终值（number取0即可）：1234567private long hash(byte[] digest, int number) &#123; return (((long) (digest[3 + number * 4] &amp; 0xFF) &lt;&lt; 24) | ((long) (digest[2 + number * 4] &amp; 0xFF) &lt;&lt; 16) | ((long) (digest[1 + number * 4] &amp; 0xFF) &lt;&lt; 8) | (digest[0 + number * 4] &amp; 0xFF)) &amp; 0xFFFFFFFFL;&#125; 3.有序缓存节点信息把n个节点Node通过以上方式取得hash值，映射到环形值空间。算法中，将以有序Map的形式在内存中缓存每个节点的Hash值对应的物理节点信息。缓存于这个内存变量中：1private final TreeMap&lt;Long, String&gt; virtualNodes ; 4.数据向值空间映射数据Job取hash的方式跟节点Node的方式一模一样，可以使用上述md5 =&gt; hash的方式同样将所有Job取得Hash映射到这个环中。 5.数据和节点映射当节点和数据都被映射到这个环上后，可以设定一个规则把哪些数据hash值放在哪些节点Node Hash值上了，规则就是：沿着顺时针方向，数据hash值向后找到第一个Node Hash值即认为该数据hash值对应的数据映射到该Node上。至此，这一个从数据到节点的映射关系就确定了。顺时针找下一个Node Hash值算法如下：12345678910111213141516171819202122public String select(Trigger trigger) &#123; String key = trigger.toString(); byte[] digest = md5(key); String node = selectForKey(hash(digest, 0)); return node; &#125; //根据数据的哈希值计算出所归属的节点Node private String selectForKey(long hash) &#123; String node; Long key = hash; if (!virtualNodes.containsKey(key)) &#123; SortedMap&lt;Long, String&gt; tailMap = virtualNodes.tailMap(key); if (tailMap.isEmpty()) &#123; key = virtualNodes.firstKey(); &#125; else &#123; key = tailMap.firstKey(); &#125; &#125; node = virtualNodes.get(key); return node; &#125; Trigger是对Job一次触发任务的抽象，这里可忽略关注，重写了toString方法返回一个标记一个Job的唯一标志，计算Hash值，从节点Hash值中按规则寻找。 6.算法优化-虚拟节点上述算法过程，会想到两个问题，第一，数据对象会不会分布不均匀，特别是新增节点或者减少节点时；第二，前文提到的如果想让部分节点多映射到一些数据对象，如何处理。虚拟节点这是解决这个问题。将一个物理节点虚拟出一定数量的虚拟节点，分散到这个值空间上，需要尽可能地随机分散开。 假设有4个物理节点Node，环上的每个色块代表一个虚拟节点涵盖的hash值区域，每种颜色代表一个物理节点。当物理节点较少时，虚拟节点数需要更高来确保更好的一致性表现。经测试，在物理节点为个位数时，虚拟节点可设置为160个，此时可带来较好的表现（后文会给出测试结果，160*n个总节点数情况下，如果发生一个节点变动，映射关系变化率基本为1/n，达到预期）。 具体做算法实现时，已知物理节点，虚拟节点数设置为160，可将这160*n的节点计算出Hash值，以Hash值为key，以物理节点标识为value，以有序Map的形式在内存中缓存，作为后续计算数据对象对应的物理节点时的查询数据。代码如下，virtualNodes中缓存着所有虚拟节点Hash值对应的物理节点信息。1234567891011121314public ConsistentHash(List&lt;String&gt; nodes) &#123; this.virtualNodes = new TreeMap&lt;&gt;(); this.identityHashCode = identityHashCode(nodes); this.replicaNumber = 160; for (String node : nodes) &#123; for (int i = 0; i &lt; replicaNumber / 4; i++) &#123; byte[] digest = md5(node.toString() + i); for (int h = 0; h &lt; 4; h++) &#123; long m = hash(digest, h); virtualNodes.put(m, node); &#125; &#125; &#125; &#125; 参考：深入一致性哈希(Consistent Hashing)算法原理 总结： 一致性哈希算法解决了负载均衡和分布式缓存中动态分配问题，使得节点的动态变化（服务器宕机、新增服务器节点）所造成的代价降到最低。 计算机的任何问题都可以通过增加一个虚拟层来解决，计算机硬件、网络和软件都是如此，网络的7层协议，每一层都可以看做是下一层的虚拟层，操作系统可以看做是计算机硬件的虚拟层，java虚拟机可以看做是操作系统的虚拟层。上述的解决节点负载不均衡的问题也采用了虚拟化的思路，将每台物理缓存服务器虚拟为缓存服务器，将虚拟服务器的hash值放在hash环上，数据key首先去寻找虚拟服务器节点，再映射得到真正的物理服务器的信息，这个思想可以在解决计算机问题上多多借鉴。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>一致性哈希</tag>
        <tag>算法，负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web服务器及Tomcat总结]]></title>
    <url>%2F2018%2F05%2F20%2Fjava%20web%E5%9F%BA%E7%A1%80%E7%AF%87%E2%80%94%E2%80%94Web%E6%9C%8D%E5%8A%A1%E5%8F%8ATomcat%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一、Web服务1.web服务器分类Unix和Linux平台下使用最广泛的免费HTTP服务器是Apache服务器，而Windows平台的服务器通常使用IIS作为Web服务器。选择Web服务器应考虑的因素有：性能、安全性、日志和统计、虚拟主机、代理服务器、缓冲服务和集成应用程序等。下面是对常见服务器的简介： IIS：Microsoft的Web服务器产品，全称是Internet Information Services。IIS是允许在公共Intranet或Internet上发布信息的Web服务器。IIS是目前最流行的Web服务器产品之一，很多著名的网站都是建立在IIS的平台上。IIS提供了一个图形界面的管理工具，称为Internet服务管理器，可用于监视配置和控制Internet服务。IIS是一种Web服务组件，其中包括Web服务器、FTP服务器、NNTP服务器和SMTP服务器，分别用于网页浏览、文件传输、新闻服务和邮件发送等方面，它使得在网络（包括互联网和局域网）上发布信息成了一件很容易的事。它提供ISAPI(Intranet Server API）作为扩展Web服务器功能的编程接口；同时，它还提供一个Internet数据库连接器，可以实现对数据库的查询和更新。 Kangle：Kangle Web服务器是一款跨平台、功能强大、安全稳定、易操作的高性能Web服务器和反向代理服务器软件。此外，Kangle也是一款专为做虚拟主机研发的Web服务器。实现虚拟主机独立进程、独立身份运行。用户之间安全隔离，一个用户出问题不影响其他用户。支持PHP、ASP、ASP.NET、Java、Ruby等多种动态开发语言。 WebSphere：WebSphere Application Server是功能完善、开放的Web应用程序服务器，是IBM电子商务计划的核心部分，它是基于Java的应用环境，用于建立、部署和管理Internet和Intranet Web应用程序，适应各种Web应用程序服务器的需要。 WebLogic：WebLogic Server是一款多功能、基于标准的Web应用服务器，为企业构建企业应用提供了坚实的基础。针对各种应用开发、关键性任务的部署，各种系统和数据库的集成、跨Internet协作等Weblogic都提供了相应的支持。由于它具有全面的功能、对开放标准的遵从性、多层架构、支持基于组件的开发等优势，很多公司的企业级应用都选择它来作为开发和部署的环境。WebLogic Server在使应用服务器成为企业应用架构的基础方面一直处于领先地位，为构建集成化的企业级应用提供了稳固的基础。 Apache：目前Apache仍然是世界上用得最多的Web服务器，其市场占有率很长时间都保持在60%以上（目前的市场份额约40%左右）。世界上很多著名的网站都是Apache的产物，它的成功之处主要在于它的源代码开放、有一支强大的开发团队、支持跨平台的应用（可以运行在几乎所有的Unix、Windows、Linux系统平台上）以及它的可移植性等方面。 Tomcat：Tomcat是一个开放源代码、运行Servlet和JSP的容器。Tomcat实现了Servlet和JSP规范。此外，Tomcat还实现了Apache-Jakarta规范而且比绝大多数商业应用软件服务器要好，因此目前也有不少的Web服务器都选择了Tomcat。 Nginx：读作”engine x”，是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP代理服务器。 Nginx是由Igor Sysoev为俄罗斯访问量第二的Rambler站点开发的，第一个公开版本0.1.0发布于2004年10月4日。其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。在2014年下半年，Nginx的市场份额达到了14%。 2、web.xml文件中可以配置哪些内容？答：web.xml用于配置Web应用的相关信息，如：监听器（listener）、过滤器（filter）、 Servlet、相关参数、会话超时时间、安全验证方式、错误页面等，下面是一些开发中常见的配置：① 配置Spring上下文加载监听器加载Spring配置文件并创建IoC容器：12345678910&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt;&lt;/listener&gt; ② 配置Spring的OpenSessionInView过滤器来解决延迟加载和Hibernate会话关闭的矛盾：1234567891011&lt;filter&gt; &lt;filter-name&gt;openSessionInView&lt;/filter-name&gt; &lt;filter-class&gt; org.springframework.orm.hibernate3.support.OpenSessionInViewFilter &lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;openSessionInView&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; ③ 配置会话超时时间为10分钟：123&lt;session-config&gt; &lt;session-timeout&gt;10&lt;/session-timeout&gt;&lt;/session-config&gt; ④ 配置404和Exception的错误页面：123456789&lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/error.jsp&lt;/location&gt;&lt;/error-page&gt;&lt;error-page&gt; &lt;exception-type&gt;java.lang.Exception&lt;/exception-type&gt; &lt;location&gt;/error.jsp&lt;/location&gt;&lt;/error-page&gt; ⑤ 配置安全认证方式：12345678910111213141516171819&lt;security-constraint&gt; &lt;web-resource-collection&gt; &lt;web-resource-name&gt;ProtectedArea&lt;/web-resource-name&gt; &lt;url-pattern&gt;/admin/*&lt;/url-pattern&gt; &lt;http-method&gt;GET&lt;/http-method&gt; &lt;http-method&gt;POST&lt;/http-method&gt; &lt;/web-resource-collection&gt; &lt;auth-constraint&gt; &lt;role-name&gt;admin&lt;/role-name&gt; &lt;/auth-constraint&gt;&lt;/security-constraint&gt;&lt;login-config&gt; &lt;auth-method&gt;BASIC&lt;/auth-method&gt;&lt;/login-config&gt;&lt;security-role&gt; &lt;role-name&gt;admin&lt;/role-name&gt;&lt;/security-role&gt; 说明：对Servlet（小服务）、Listener（监听器）和Filter（过滤器）等Web组件的配置，Servlet 3规范提供了基于注解的配置方式，可以分别使用@WebServlet、@WebListener、@WebFilter注解进行配置。 补充：如果Web提供了有价值的商业信息或者是敏感数据，那么站点的安全性就是必须考虑的问题。安全认证是实现安全性的重要手段，认证就是要解决“Are you who you say you are?”的问题。认证的方式非常多，简单说来可以分为三类：A. What you know? — 口令B. What you have? — 数字证书（U盾、密保卡）C. Who you are? — 指纹识别、虹膜识别在Tomcat中可以通过建立安全套接字层（Secure Socket Layer, SSL）以及通过基本验证或表单验证来实现对安全性的支持。 二、Tomcat总结1.Tomcat架构Tomcat中最顶层的容器是Server，代表着整个服务器，从上图中可以看出，一个Server可以包含至少一个Service，用于具体提供服务。Service主要包含两个部分：Connector和Container。从上图中可以看出 Tomcat 的心脏就是这两个组件，他们的作用如下： Connector用于处理连接相关的事情，并提供Socket与Request和Response相关的转化; Container用于封装和管理Servlet，以及具体处理Request请求； 一个Tomcat中只有一个Server，一个Server可以包含多个Service，一个Service只有一个Container，但是可以有多个Connectors，这是因为一个服务可以有多个连接，如同时提供Http和Https链接，也可以提供向相同协议不同端口的连接,示意图如下 小结：（1）Tomcat中只有一个Server，一个Server可以有多个Service，一个Service可以有多个Connector和一个Container；（2）Server掌管着整个Tomcat的生死大权；（4）Service 是对外提供服务的；（5）Connector用于接受请求并将请求封装成Request和Response来具体处理；（6）Container用于封装和管理Servlet，以及具体处理request请求； Connector和Container的微妙关系由上述内容我们大致可以知道一个请求发送到Tomcat之后，首先经过Service然后会交给我们的Connector，Connector用于接收请求并将接收的请求封装为Request和Response来具体处理，Request和Response封装完之后再交由Container进行处理，Container处理完请求之后再返回给Connector，最后在由Connector通过Socket将处理的结果返回给客户端，这样整个请求的就处理完了！ Connector最底层使用的是Socket来进行连接的，Request和Response是按照HTTP协议来封装的，所以Connector同时需要实现TCP/IP协议和HTTP协议！ 《四张图带你了解Tomcat系统架构–让面试官颤抖的Tomcat回答系列！》 2.解释什么是Jasper?Jasper是Tomcat的JSP引擎，它解析JSP文件，将它们编译成JAVA代码作为servlet。在运行时，Jasper允许自动检测JSP文件的更改并重新编译它们 3.请解释Tomcat的默认端口是什么?Tomcat的默认端口是8080。在本地机器上初始化Tomcat之后，可以验证Tomcat是否正在运行URL:http://localhost:8080 4.请解释Tomcat中使用的连接器是什么?在Tomcat中，使用了两种类型的连接器：HTTP连接器:它有许多可以更改的属性，以确定它的工作方式和访问功能，如重定向和代理转发AJP连接器:它以与HTTP连接器相同的方式工作，但是他们使用的是HTTP的AJP协议。AJP连接器通常通过插件技术mod_jk在Tomcat中实现 5.解释如何使用WAR文件部署web应用程序?在Tomcat的web应用程序目录下，jsp、servlet和它们的支持文件被放置在适当的子目录中。你可以将web应用程序目录下的所有文件压缩到一个压缩文件中，以.war文件扩展名结束。你可以通过在webapps目录中放置WAR文件来执行web应用程序。当一个web服务器开始执行时，它会将WAR文件的内容提取到适当的webapps子目录中。 6.解释什么是Tomcat Valve?说明Tomcat配置了多少个Valve?Tomcat Valve——Tomcat 4引入的新技术，它允许您将Java类的实例链接到一个特定的Catalina容器。Tomcat配置了四种类型的Valve： 访问日志 远程地址过滤 远程主机过滤器 客户请求记录器 7.解释servlet如何完成生命周期?在Tomcat上运行的典型servlet生命周期如下： Tomcat通过它的其中一个连接器接收来自客户端的请求 进程请求Tomcat将此请求映射为适当的Servlet 一旦请求被定向到适当的servlet，Tomcat就会验证servlet类是否已经加载。如果不是,Tomcat将servlet包装成Java字节码，这是由JVM执行的，并形成servlet的实例 Tomcat通过调用它的init来启动servlet，它包含能够筛选Tomcat配置文件并相应地采取行动的代码，并声明它可能需要的任何资源 一旦servlet启动，Tomcat就可以调用servlet的服务方法来进行请求 在servlet的生命周期中，Tomcat和servlet可以通过使用侦听器类来进行协调或通信，从而跟踪各种状态变化的servlet 删除servlet，Tomcat调用servlet销毁方法 8.Tomcat优化经验一、关掉对web.xml的监视，把jsp提前编辑成Servlet。有富余物理内存的情况，加大tomcat使用的jvm的内存 二、服务器资源。服务器所能提供CPU、内存、硬盘的性能对处理能力有决定性影响。(1) 对于高并发情况下会有大量的运算，那么CPU的速度会直接影响到处理速度。(2) 内存在大量数据处理的情况下，将会有较大的内存容量需求，可以用-Xmx -Xms -XX:MaxPermSize等参数对内存不同功能块进行划分。我们之前就遇到过内存分配不足，导致虚拟机一直处于full GC，从而导致处理能力严重下降。(3) 硬盘主要问题就是读写性能，当大量文件进行读写时，磁盘极容易成为性能瓶颈。最好的办法还是利用下面提到的缓存。 三、利用缓存和压缩对于静态页面最好是能够缓存起来，这样就不必每次从磁盘上读。这里我们采用了Nginx作为缓存服务器，将图片、css、js文件都进行了缓存，有效的减少了后端tomcat的访问。另外，为了能加快网络传输速度，开启gzip压缩也是必不可少的。但考虑到tomcat已经需要处理很多东西了，所以把这个压缩的工作就交给前端的Nginx来完成。 除了文本可以用gzip压缩，其实很多图片也可以用图像处理工具预先进行压缩，找到一个平衡点可以让画质损失很小而文件可以减小很多。曾经我就见过一个图片从300多kb压缩到几十kb，自己几乎看不出来区别。 四、采用集群单个服务器性能总是有限的，最好的办法自然是实现横向扩展，那么组建tomcat集群是有效提升性能的手段。我们还是采用了Nginx来作为请求分流的服务器，后端多个tomcat共享session来协同工作。可以参考之前写的《利用nginx+tomcat+memcached组建web服务器负载均衡》。 五、 优化tomcat参数这里以tomcat7的参数配置为例，需要修改conf/server.xml文件，主要是优化连接配置，关闭客户端dns查询。12345678910&lt;Connector port="8080" protocol="org.apache.coyote.http11.Http11NioProtocol" connectionTimeout="20000" redirectPort="8443" maxThreads="500" minSpareThreads="20" acceptCount="100" disableUploadTimeout="true" enableLookups="false" URIEncoding="UTF-8" /&gt;]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>Interview</tag>
        <tag>java web</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[详解IO的使用]]></title>
    <url>%2F2018%2F05%2F20%2F%E8%AF%A6%E8%A7%A3IO%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[I/O类库中使用“流”这个抽象概念。Java对设备中数据的操作是通过流的方式。表示任何有能力产出数据的数据源对象，或者是有能力接受数据的接收端对象。“流”屏蔽了实际的I/O设备中处理数据的细节。IO流用来处理设备之间的数据传输。设备是指硬盘、内存、键盘录入、网络等。IO的分类可以为： 流按操作数据类型的不同分为两种：字节流与字符流。 流按流向分为：输入流，输出流（以程序为参照物，输入到程序，或是从程序输出）一、字节流1、InpustreamInputStream有read方法，一次读取一个字节，OutputStream的write方法一次写一个int。这两个类都是抽象类。意味着不能创建对象，那么需要找到具体的子类来使用。操作流的步骤都是： 第一步：1：打开流（即创建流）第二步：2：通过流读取内容第三步：3：用完后，关闭流资源 案例一：使用 read()方法，一次读取一个字节,读到文件末尾返回-1.12345678910private static void showContent(String path) throws IOException &#123; // 打开流 FileInputStream fis = new FileInputStream(path); int len; while ((len = fis.read()) != -1) &#123; System.out.print((char) len); &#125; // 使用完关闭流 fis.close(); 案例二：使用read()方法的时候，可以将读到的数据装入到字节数组中，一次性的操作数组，可以提高效率。1234567891011121314private static void showContent2(String path) throws IOException &#123; // 打开流 FileInputStream fis = new FileInputStream(path); // 通过流读取内容 byte[] byt = new byte[1024]; int len = fis.read(byt); for (int i = 0; i &lt;len; i++) &#123; System.out.print(byt[i]); &#125; // 使用完关闭流 fis.close(); &#125; 案例三：使用read(byte[] b,int off,int len)1234567891011121314151617181920212223242526/** * 把数组的一部分当做流的容器来使用 * read(byte[] b,int off,int len) */ private static void showContent3(String path) throws IOException &#123; // 打开流 FileInputStream fis = new FileInputStream(path); // 通过流读取内容 byte[] byt = new byte[1024]; // 从什么地方开始存读到的数据 int start = 5; // 希望最多读多少个(如果是流的末尾，流中没有足够数据) int maxLen = 6; // 实际存放了多少个 int len = fis.read(byt, start, maxLen); for (int i = start; i &lt; start + maxLen; i++) &#123; System.out.print((char) byt[i]); &#125; // 使用完关闭流 fis.close(); &#125; 案例四（推荐使用）：使用缓冲(提高效率),并循环读取(读完所有内容). 123456789101112 /** * 使用字节数组当缓冲 * */ private static void showContent7(String path) throws IOException &#123; FileInputStream fis = new FileInputStream(path); byte[] byt = new byte[1024]; int len = 0; while ((len = fis.read(byt)) != -1) &#123; System.out.println(new String(byt, 0, len)); &#125; fis.close();&#125; 2、OutputStreamOutputStram 的write方法，一次只能写一个字节。成功的向文件中写入了内容。但是并不高效，如何提高效率呢？可以使用缓冲，在OutputStram类中有write(byte[] b)方法，将 b.length个字节从指定的 byte 数组写入此输出流中。1234567891011private static void writeTxtFile(String path) throws IOException &#123; // 1：打开文件输出流，流的目的地是指定的文件 FileOutputStream fos = new FileOutputStream(path,true); // 2：通过流向文件写数据 byte[] byt = "java".getBytes(); fos.write(byt); // 3:用完流后关闭流 fos.close(); &#125; 3、输入输出流综合使用——文件拷贝实现123456789101112131415161718public static void copyFile(String srcPath, String destPath) throws IOException &#123; // 打开输入流，输出流 FileInputStream fis = new FileInputStream(srcPath); FileOutputStream fos = new FileOutputStream(destPath); // 读取和写入信息 int len = 0; // 使用字节数组，当做缓冲区 byte[] byt = new byte[1024]; while ((len = fis.read(byt)) != -1) &#123; fos.write(byt, 0, len); &#125; // 关闭流 fis.close(); fos.close(); &#125; 可以根据拷贝的需求调整数组的大小，一般是1024的整数倍。使用缓冲后效率大大提高。目前我们是抛出处理，一旦出现了异常，close就没有执行，也就没有释放资源。那么为了保证close的执行该如何处理呢。那么就需要使用try{} catch(){}finally{}语句。try中放入可能出现异常的语句，catch是捕获异常对象，fianlly是一定要执行的代码。12345678910111213141516171819202122232425262728293031323334public static void copyFile(String srcPath, String destPath) &#123; FileInputStream fis = null; FileOutputStream fos = null; try &#123; fis = new FileInputStream(srcPath); fos = new FileOutputStream(destPath); byte[] byt = new byte[1024 * 1024]; int len = 0; while ((len = fis.read(byt)) != -1) &#123; fos.write(byt, 0, len); &#125; &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; finally &#123; try &#123; if (fis != null) &#123; fis.close(); &#125; &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; finally &#123; if (fos != null) &#123; try &#123; fos.close(); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125; &#125; &#125; &#125; 大量的异常捕获代码使得以上代码变得十分臃肿难看，好在java7提供了TWR（try-with-resource）语法糖，由于很多外部资源类都间接的实现了AutoCloseable接口（单方法回调接口），因此可以利用TWR语法在try结束的时候通过回调的方式自动调用外部资源类的close()方法，避免书写冗长的finally代码块。`123456789101112public static void copyByTWR(String srcPath, String destPath)&#123; try( FileInputStream fis = new FileInputStream(srcPath); FileOutputStream fos = new FileOutputStream(destPath))&#123; byte[] byt = new byte[1024 * 1024]; int len = 0; while ((len = fis.read(byt)) != -1) &#123; fos.write(byt, 0, len); &#125; &#125;catch (IOException e)&#123; throw new RuntimeException(e); &#125;&#125; 当try语句块运行结束时，FileInputStream / FileOutputStream会被自动关闭。这是因为FileInputStream实现了java中的java.lang.AutoCloseable接口。所有实现了这个接口的类都可以在try-with-resources结构中使用上面的例子在try关键字后的括号里创建了两个资源——FileInputStream 和FileOutputStream。当程序运行离开try语句块时，这两个资源都会被自动关闭,这些资源将按照他们被创建顺序的逆序来关闭。首先FileOutputStream会被关闭，然后FileInputStream会被关闭。怎么实现对资源的关闭呢？当try-with-resources结构中抛出一个异常，同时FileInputStream被关闭时（调用了其close方法）也抛出一个异常，try-with-resources结构中抛出的异常会向外传播，而FileInputStream被关闭时抛出的异常被抑制了。这与文章开始处利用旧风格代码的例子（在finally语句块中关闭资源）相反。 具体参考：Java 7中的Try-with-resources 4、缓冲流Java其实提供了专门的字节流缓冲来提高效率。BufferedInputStream 和 BufferedOutputStream。BufferedOutputStream和BufferedOutputStream类可以通过减少读写次数来提高输入和输出的速度。它们内部有一个缓冲区，用来提高处理效率。查看API文档，发现可以指定缓冲区的大小。其实内部也是封装了字节数组。没有指定缓冲区大小，默认的字节是8192。显然缓冲区输入流和缓冲区输出流要配合使用。首先缓冲区输入流会将读取到的数据读入缓冲区，当缓冲区满时，或者调用flush方法，缓冲输出流会将数据写出。注意：当然使用缓冲流来进行提高效率时，对于小文件可能看不到性能的提升。但是文件稍微大一些的话，就可以看到实质的性能提升了。1234567891011121314151617181920212223242526272829public class Test &#123; public static void main(String[] args) throws IOException &#123; String srcPath = "c:\\a.mp3"; String destPath = "d:\\copy.mp3"; copyFile(srcPath, destPath); &#125; public static void copyFile(String srcPath, String destPath) throws IOException &#123; // 打开输入流，输出流 FileInputStream fis = new FileInputStream(srcPath); FileOutputStream fos = new FileOutputStream(destPath); // 使用缓冲流 BufferedInputStream bis = new BufferedInputStream(fis); BufferedOutputStream bos = new BufferedOutputStream(fos); // 读取和写入信息 int len = 0; while ((len = bis.read()) != -1) &#123; bos.write(len); &#125; // 关闭流 bis.close(); bos.close(); &#125;&#125; 二、字符流 计算机并不区分二进制文件与文本文件。所有的文件都是以二进制形式来存储的，因此，从本质上说，所有的文件都是二进制文件。所以字符流是建立在字节流之上的，它能够提供字符层次的编码和解码。可以说字符流就是：字节流 + 编码表，为了更便于操作文字数据。字符流的抽象基类：Reader ， Writer。由这些类派生出来的子类名称都是以其父类名作为子类名的后缀，如FileReader、FileWriter。 1、Reader1int read() 读取一个字符。返回的是读到的那个字符。如果读到流的末尾，返回-1.1int read(char[]) 将读到的字符存入指定的数组中，返回的是读到的字符个数，也就是往数组里装的元素的个数。如果读到流的末尾，返回-1.1close() 读取字符其实用的是window系统的功能，就希望使用完毕后，进行资源的释放由于Reader也是抽象类，所以想要使用字符输入流需要使用Reader的实现类——FileReader。1，用于读取文本文件的流对象。2，用于关联文本文件。构造函数：在读取流对象初始化的时候，必须要指定一个被读取的文件。如果该文件不存在会发生FileNotFoundException。1234567891011/** * 使用字符流读取文件内容 */public static void readFileByReader(String path) throws Exception &#123; Reader reader = new FileReader(path); int len = 0; while ((len = reader.read()) != -1) &#123; System.out.print((char) len); &#125; reader.close();&#125; 2、Writer123456789write(ch): //将一个字符写入到流中。write(char[]):// 将一个字符数组写入到流中。write(String): //将一个字符串写入到流中。flush(): //刷新流，将流中的数据刷新到目的地中，流还存在。close(): //关闭资源：在关闭前会先调用flush()，刷新流中的数据去目的地。然流关闭。 基本方法和OutputStream 类似，有write方法，功能更多一些。可以接收字符串。Writer是抽象类无法创建对象，Writer的实现子类为FileWriter。默认的FileWriter方法新值会覆盖旧值，想要实现追加功能需要使用如下构造函数创建输出流 append值为true了。12FileWriter(String fileName, boolean append)FileWriter(File file, boolean append) 3、文件拷贝——完善异常处理风格一次读一个字符就写一个字符，效率不高。把读到的字符放到字符数组中，再一次性的写出，缓冲数组可以提高效率。1234567891011121314151617181920212223242526272829303132333435363738/** * 使用字符流拷贝文件，有完善的异常处理 */ public static void copyFile2(String path1, String path2) &#123; Reader reader = null; Writer writer = null; try &#123; // 打开流 reader = new FileReader(path1); writer = new FileWriter(path2); // 进行拷贝 int ch = -1; char [] arr=new char[1024]; while ((ch = reader.read(arr)) != -1) &#123; writer.write(ch); &#125; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; finally &#123; // 关闭流，注意一定要能执行到close()方法，所以都要放到finally代码块中 try &#123; if (reader != null) &#123; reader.close(); &#125; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; finally &#123; try &#123; if (writer != null) &#123; writer.close(); &#125; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; &#125; &#125; 同样可以用TWR风格进行简写，将大量finally中的资源关闭操作省略掉，声明赋值语句放入到try()中即可。 4、缓冲流使用字符流缓冲区拷贝文本文件可以提高效率，Reader有一个子类BufferedReader， 子类继承父类显然子类可以重写父类的方法可以增加自己的新方法。例如一次读一行就是常用的操作.那么BufferedReader类就提供了这个方法,可以查看readLine()方法具备 一次读取一个文本行的功能。很显然,该子类可以对功能进行增强。12345678910111213141516171819202122232425private static void copyFile(File srcFile, File destFile)throws IOException &#123; // 创建字符输入流 FileReader fr = new FileReader(srcFile); // 创建字符输出流 FileWriter fw = new FileWriter(destFile); // 字符输入流的缓冲流 BufferedReader br = new BufferedReader(fr); // 字符输出流的缓冲流 BufferedWriter bw = new BufferedWriter(fw); String line = null; // 一次读取一行 while ((line = br.readLine()) != null) &#123; // 一次写出一行. bw.write(line); // 刷新缓冲 bw.flush(); // 进行换行,由于readLine方法默认没有换行.需要手动换行 bw.newLine(); &#125; // 关闭流 br.close(); bw.close(); &#125; 三、装饰器模式：使用分层对象来动态透明的向单个对象中添加责任（功能）。装饰器指定包装在最初的对象周围的所有对象都具有相同的基本接口。某些对象是可装饰的，可以通过将其他类包装在这个可装饰对象的四周，来将功能分层。装饰器必须具有和他所装饰的对象相同的接口。Java I/O类库需要多种不同的功能组合，所以使用了装饰器模式。Filterxxx类是JavaIO提供的装饰器基类，即我们要想实现一个新的装饰器，就要继承这些类。 继承实现的增强类：优点：代码结构清晰，而且实现简单缺点：对于每一个的需要增强的类都要创建具体的子类来帮助其增强，这样会导致继承体系过于庞大。 修饰模式实现的增强类：优点：内部可以通过多态技术对多个需要增强的类进行增强缺点：需要内部通过多态技术维护需要增强的类的实例。进而使得代码稍微复杂。 四、面试总结：1、为了提高读写性能，可以采用什么流针对读写对象的不同，字节流可以采用带缓冲区的BufferedInputStream和BufferedOutputStream，字符流可以采用带缓冲区的BufferedReader和BufferedWriter。 2、Java中有几种类型的流字节流和字符流。字节流继承于InputStream、OutputStream，字符流继承于Reader、Writer。在java.io包中还有许多其他的流，主要是为了提高性能和使用方便。关于Java的I/O需要注意的有两点：一是两种对称性（输入和输出的对称性，字节和字符的对称性）；二是两种设计模式（适配器模式和装潢模式）。另外Java中的流不同于C#的是它只有一个维度一个方向。 3、JDK 为每种类型的流提供了一些抽象类以供继承，分别是哪些类Java中的流分为两种，一种是字节流，另一种是字符流，分别由四个抽象类来表示（每种流包括输入和输出两种所以一共四个）:InputStream，OutputStream，Reader，Writer。Java中其他多种多样变化的流均是由它们派生出来的. 4、对文本文件操作用什么I/O流？FileReader/FileWriter 5、对各种基本数据类型和String类型的读写，采用什么流？ DataInputStream、DataOutputStream 6、能指定字符编码的 I/O 流类型是什么？12BufferedReader/BufferedWriterBufferedInputStream/BufferedOutputStream 回答以上问题需要分清各个IO流子类的应用场景： FileInputStream/FileOutputStream 需要逐个字节处理原始二进制流的时候使用，效率低下。FileReader/FileWriter 需要组个字符处理的时候使用。StringReader/StringWriter 需要处理字符串的时候，可以将字符串保存为字符数组。PrintStream/PrintWriter 用来包装FileOutputStream 对象，方便直接将String字符串写入文件 。Scanner 用来包装System.in流，很方便地将输入的String字符串转换成需要的数据类型。InputStreamReader/OutputStreamReader , 字节和字符的转换桥梁，在网络通信或者处理键盘输入的时候用。BufferedReader/BufferedWriter， BufferedInputStream/BufferedOutputStream， 缓冲流用来包装字节流后者字符流，提升IO性能，BufferedReader还可以方便地读取一行，简化编程。SequenceInputStream(InputStream s1, InputStream s2)序列流，合并流对象时使用.ObjectInputStream、ObjectOutputStream，方法用于序列化对象并将它们写入一个流，另一个方法用于读取流并反序列化对象。ByteArrayInputStream、ByteArrayOutputStream，操作数组DataInputStream、DataOutputStream操作基本数据类型和字符串。 7、写一个方法，输入一个文件名和一个字符串，统计这个字符串在这个文件中出现的次数。123456789101112131415161718192021222324252627282930313233public final class MyUtil &#123; // 工具类中的方法都是静态方式访问的因此将构造器私有不允许创建对象(绝对好习惯) private MyUtil() &#123; throw new AssertionError(); &#125; /** * 统计给定文件中给定字符串的出现次数 * * @param filename 文件名 * @param word 字符串 * @return 字符串在文件中出现的次数 */ public static int countWordInFile(String filename, String word) &#123; int counter = 0; try (FileReader fr = new FileReader(filename)) &#123; try (BufferedReader br = new BufferedReader(fr)) &#123; String line = null; while ((line = br.readLine()) != null) &#123; int index = -1; while (line.length() &gt;= word.length() &amp;&amp; (index = line.indexOf(word)) &gt;= 0) &#123; counter++; line = line.substring(index + word.length()); &#125; &#125; &#125; &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; return counter; &#125;&#125;]]></content>
      <categories>
        <category>Java IO</category>
      </categories>
      <tags>
        <tag>Interview</tag>
        <tag>java</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[结合IO类讲讲装饰者模式]]></title>
    <url>%2F2018%2F05%2F20%2Fjava%E5%9F%BA%E7%A1%80%E4%B9%8BIO%E6%B5%81%EF%BC%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[java IO流的设计是基于装饰者模式&amp;适配模式，面对IO流庞大的包装类体系，核心是要抓住其功能所对应的装饰类。 装饰模式又名包装（Wrapper）模式。装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案。装饰模式通过创建一个包装对象，也就是装饰，来包裹真实的对象。装饰模式以对客户端透明的方式动态地给一个对象附加上更多的责任。换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在不创造更多子类的情况下，将对象的功能加以扩展。装饰模式把客户端的调用委派到被装饰类。装饰模式的关键在于这种扩展是完全透明的。装饰者的角色：抽象构件角色（Component）：给出一个抽象接口，以规范准备接收附加责任的对象。具体构件角色（Concrete Component）：定义将要接收附加责任的类。装饰角色（Decorator）：持有一个构件（Component）对象的引用，并定义一个与抽象构件接口一致的接口。具体装饰角色（Concrete Decorator）：负责给构件对象“贴上”附加的责任。 实现案例：12345//抽象构件角色public interface Component&#123; public void doSomething();&#125; 123456789//具体构件角色public class ConcreteComponent implements Component&#123; @Override public void doSomething() &#123; System.out.println("功能A"); &#125;&#125; 1234567891011121314151617//装饰者角色public class Decorator implements Component&#123; //维护一个抽象构件角色 private Component component; public Decorator(Component component) &#123; this.component = component; &#125; @Override public void doSomething() &#123; component.doSomething(); &#125;&#125; 123456789101112131415161718192021//具体装饰者角色public class ConcreteDecorator1 extends Decorator&#123; public ConcreteDecorator1(Component component) &#123; super(component); &#125; @Override public void doSomething() &#123; super.doSomething(); this.doAnotherThing(); &#125; private void doAnotherThing() &#123; System.out.println("功能B"); &#125;&#125; 以上就是装饰者模式的一个极简代码思路，实际上IO流的装饰体系也是在对上面思路的一中具体实现。JAVA-IO流体系：在IO中，具体构件角色是节点流，装饰角色是过滤流。1、继承自InputStream/OutputStream的流都是用于向程序中输入/输出数据，且数据的单位都是字节(byte=8bit)，如图，深色的为节点流，浅色的为过滤流。2、继承自Reader/Writer的流都是用于向程序中输入/输出数据，且数据的单位都是字符(2byte=16bit)，如图，深色的为节点流，浅色的为过滤流。从图中可以看出，InputStream就是装饰者模式中的超类（Component），ByteArrayInputStream，FileInputStream相当于被装饰者（ConcreteComponent），这些类都提供了最基本的字节读取功能。而另外一个和这两个类是同一级的类FilterInputStream即是装饰者（Decorator），BufferedInputStream，DataInputStream，PushbackInputStream…这些都是被装饰者装饰后形成的成品。为什么可以说：装饰模式可以在不创造更多子类的情况下，将对象的功能加以扩展，能理解这一点就能很好的掌握装饰者设计模式的精髓，如果在InputStream这里扩展出FilterInputStream类下面的装饰类，那么针对FileInputStream和ByteArrayInputStream就都要去实现一次BufferedInputStream了，那么可能就会衍生出BufferedFileInputStream和BufferedByteArrayInputStream这样的类，如果按照这样的扩展方式去添加功能，对于添加功能的子类来说简直是一场噩梦，好在装饰着模式很好的解决了这个问题，现在我们只需要在过滤流类这里维护一个超类，不论传入的是什么具体的节点流，那么都只要套一层装饰，就能对功能方法进行加强。如果想要对文件输入流进行缓存加强可以这样装饰：12File file = new File ("hello.txt");BufferedInputStream inBuffered=new BufferedInputStream (new FileInputStream(file)); 如果想要对字节数组输入流进行缓存加强可以这样装饰：12byte[] byts="Hello".getBytes();BufferedInputStream bf=new BufferedInputStream(new ByteArrayInputStream(byts)); 那么节点流上的类就可以平行扩展，而装饰者同样可以按照功能进行另外一个维度的扩展，调用的时候就可以按需进行组合装饰，这样就可以减少了子类还将对象的功能进行扩展，不得不佩服前人在该设计模式上的智慧，理解了这装饰着模式后，就应该对java中IO流的体系进行梳理：节点流类型对文件操作的字符流有FileReader/FileWriter，字节流有FileInputStream/FileOutputStream。过滤流类型 缓冲流：缓冲流要“套接”在相应的节点流之上，对读写的数据提供了缓冲的功能，提高了读写效率，同时增加了一些新的方法。字节缓冲流有BufferedInputStream / BufferedOutputStream，字符缓冲流有BufferedReader / BufferedWriter，字符缓冲流分别提供了读取和写入一行的方法ReadLine和NewLine方法。对于输出的缓冲流，写出的数据，会先写入到内存中，再使用flush方法将内存中的数据刷到硬盘。所以，在使用字符缓冲流的时候，一定要先flush，然后再close，避免数据丢失。转换流：用于字节数据到字符数据之间的转换。字符流InputStreamReader / OutputStreamWriter。其中，InputStreamReader需要与InputStream“套接”，OutputStreamWriter需要与OutputStream“套接”。数据流：提供了读写Java中的基本数据类型的功能。DataInputStream和DataOutputStream分别继承自InputStream和OutputStream，需要“套接”在InputStream和OutputStream类型的节点流之上。对象流：用于直接将对象写入写出。流类有ObjectInputStream和ObjectOutputStream，本身这两个方法没什么，但是其要写出的对象有要求，该对象必须实现Serializable接口，来声明其是可以序列化的。否则，不能用对象流读写。(api以及demo在文末)重点梳理一下：Java中Inputstream/OutputStream与Reader/Writer的区别 Reader/Writer和InputStream/OutputStream分别是I/O库提供的两套平行独立的等级机构， InputStream、OutputStream是用来处理8位元的流，也就是用于读写ASCII字符和二进制数据；Reader、Writer是用来处理16位元的流，也就是用于读写Unicode编码的字符。 在JAVA语言中，byte类型是8位的，char类型是16位的，所以在处理中文的时候需要用Reader和Writer。 两种等级机构下，有一道桥梁InputStreamReader、OutputStreamWriter负责进行InputStream到Reader的适配和由OutputStream到Writer的适配。 在Java中，有不同类型的Reader/InputStream输入流对应于不同的数据源： FileReader/FileInputStream 用于从文件输入；CharArrayReader/ByteArrayInputStream用于从程序中的字符数组输入； StringReader/StringBufferInputStream 用于从程序中的字符串输入；PipedReader/PipeInputStream用于读取从另一个线程中的 - PipedWriter/PipeOutputStream写入管道的数据。 相应的也有不同类型的Writer/OutputStream输出流对应于不同的数据源：FileWriter/FileOutputStream，CharArrayWriter/ByteArrayOutputStream，StringWriter，PipeWriter/PipedOutputStream。 IO流的应用选择1、确定选用流对象的步骤确定原始数据的格式确定是输入还是输出是否需要转换流数据的来源（去向）是否需要缓冲是否需要格式化输出 按照数据格式分二进制格式（只要确定不是纯文本格式的），InputStream, OutputStream, 及其所有带Stream子类 纯文本格式（比如英文/汉字/或其他编码文字）：Reader, Writer, 及其相关子类 按照输入输出分输入：Reader， InputStream，及其相关子类输出：Writer，OutputStream，及其相关子类 按缓冲功能分要缓冲：BufferedInputStream, BufferedOuputStream, BuffereaReader, BufferedWriter 按照格式化输出需要格式化输出：PrintStream（输出字节），PrintWriter（输出字符） 特殊需求从Stream转化为Reader，Writer：InputStreamReader，OutputStreamWriter对象输入输出流：ObjectInputStream，ObjectOutputStream进程间通信：PipeInputStream，PipeOutputStream，PipeReader，PipeWriter合并输入：SequenceInputStream更特殊的需要：PushbackInputStream, PushbackReader, LineNumberInputStream, LineNumberReader1234567891011121314151617181920212223242526272829303132333435363738//对象流案例public class Demo3 &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; Cat cat = new Cat("tom", 3); FileOutputStream fos = new FileOutputStream(new File("c:\\Cat.txt")); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(cat); System.out.println(cat); oos.close(); // 反序列化 FileInputStream fis = new FileInputStream(new File("c:\\Cat.txt")); ObjectInputStream ois = new ObjectInputStream(fis); Object readObject = ois.readObject(); Cat cat2 = (Cat) readObject; System.out.println(cat2); fis.close();&#125;class Cat implements Serializable &#123; public String name; public int age; public Cat() &#123; &#125; public Cat(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public String toString() &#123; return "Cat [name=" + name + ", age=" + age + "]"; &#125;&#125; 123456789101112131415161718//DataInputStream 基本数据类型和String//操作基本数据类型的方法：int readInt()://一次读取四个字节，并将其转成int值。boolean readBoolean()://一次读取一个字节。short readShort();long readLong();//剩下的数据类型一样。String readUTF()://按照utf-8修改版读取字符。注意，它只能读writeUTF()//写入的字符数据。DataOutputStreamDataOutputStream(OutputStream)://操作基本数据类型的方法:writeInt(int)：//一次写入四个字节。//注意和write(int)不同。write(int)只将该整数的最低一个8位写入。剩余三个8位丢弃。writeBoolean(boolean);writeShort(short);writeLong(long);//剩下是数据类型也也一样。writeUTF(String)://按照utf-8修改版将字符数据进行存储。只能通过readUTF读取。 转换流：InputStreamReader：字节到字符的桥梁。OutputStreamWriter：字符到字节的桥梁。123456//从字节流中读取字符信息BufferedReader bf=new InputStreamReader(new FileInputStream("src"));//将字符信息用指定字节编码写出OutputStreamWriter bw=new OutputStreamWriter(new FileOutputStream("target"),"utf-8"); bw.write("Hello"); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class TestIo &#123; public class Demo4 &#123; public static void main(String[] args) throws IOException &#123; File file = new File("c:\\a.txt"); File fileGBK = new File("c:\\gbk.txt"); File fileUTF = new File("c:\\utf.txt"); // 写入 // 使用系统默认码表写入 testWriteFile(file); // 使用gbk编码向gbk文件写入信息 testWriteFile(fileGBK, "gbk"); // 使用utf-8向utf-8文件中写入信息 testWriteFile(fileUTF, "utf-8"); // 读取 // 默认编码 testReadFile(file); // 传入gbk编码文件,使用gbk解码 testReadFile(fileGBK, "gbk"); // 传入utf-8文件,使用utf-8解码 testReadFile(fileUTF, "utf-8"); &#125; // 使用系统码表将信息写入到文件中 private static void testWriteFile(File file) throws IOException &#123; FileOutputStream fos = new FileOutputStream(file); OutputStreamWriter ops = new OutputStreamWriter(fos); ops.write("中国"); ops.close(); &#125; // 使用指定码表,将信息写入到文件中 private static void testWriteFile(File file, String encod) throws IOException &#123; FileOutputStream fos = new FileOutputStream(file); OutputStreamWriter ops = new OutputStreamWriter(fos, encod); ops.write("中国"); ops.close(); &#125; // 该方法中nputStreamReader使用系统默认编码读取文件. private static void testReadFile(File file) throws IOException &#123; FileInputStream fis = new FileInputStream(file); InputStreamReader ins = new InputStreamReader(fis); int len = 0; while ((len = ins.read()) != -1) &#123; System.out.print((char) len); &#125; ins.close(); &#125; // 该方法适合用指定编码读取文件 private static void testReadFile(File file, String encod) throws IOException &#123; FileInputStream fis = new FileInputStream(file); InputStreamReader ins = new InputStreamReader(fis, encod); int len = 0; while ((len = ins.read()) != -1) &#123; System.out.print((char) len); &#125; ins.close(); &#125;&#125;]]></content>
      <categories>
        <category>Java IO</category>
      </categories>
      <tags>
        <tag>Interview</tag>
        <tag>java</tag>
        <tag>IO</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO里的老熟人File类]]></title>
    <url>%2F2018%2F05%2F20%2Fjava%E5%9F%BA%E7%A1%80%E4%B9%8BIO%E6%B5%81%EF%BC%88File%E7%AF%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[File类描述的是一个文件或文件夹。（文件夹也可以称为目录），该类的出现是对文件系统的中的文件以及文件夹进行对象的封装。可以通过对象的思想来操作文件以及文件夹，通过该对象的方法得到文件或文件夹的信息方便了对文件与文件夹的属性信息进行操作。文件包含很多的信息:如文件名、创建修改时间、大小、可读可写属性等。 1.基本API（1）.通过将给定路径来创建一个新File实例。1new File(String pathname); （2）.根据parent路径名字符串和child路径名创建一个新File实例。parent是指上级目录的路径，完整的路径为parent+child.1new File(String parent, String child); （3）.根据parent抽象路径名和child路径名创建一个新File实例。 parent是指上级目录的路径，完整的路径为parent.getPath()+child.说明：如果指定的路径不存在（没有这个文件或是文件夹），不会抛异常，这时file.exists()返回false。1new File(File parent, String child); 说明：如果指定的路径不存在（没有这个文件或是文件夹），不会抛异常，这时file.exists()返回false。 （4）创建：12345678createNewFile() //在指定位置创建一个空文件，成功就返回true，如果已存在就不创建然后返回falsemkdir() //在指定位置创建目录，这只会创建最后一级目录，如果上级目录不存在就抛异常。mkdirs() //在指定位置创建目录，这会创建路径中所有不存在的目录。renameTo(File dest) //重命名文件或文件夹，也可以操作非空的文件夹，文件不同时相当于文件的剪切,剪切时候不能操作非空的文件夹。 //移动/重命名成功则返回true，失败则返回false。 （5）.删除：12345delete()//删除文件或一个空文件夹，如果是文件夹且不为空，则不能删除，成功返回true，失败返回false。deleteOnExit()//在虚拟机终止时，请求删除此抽象路径名表示的文件或目录，保证程序异常时创建的临时文件也可以被删除 （6）.判断：123456789exists() //文件或文件夹是否存在。isFile() //是否是一个文件，如果不存在，则始终为false。isDirectory() //是否是一个目录，如果不存在，则始终为false。isHidden() //是否是一个隐藏的文件或是否是隐藏的目录。isAbsolute() //测试此抽象路径名是否为绝对路径名。 （7）.获取：1234567891011121314151617181920212223getName() //获取文件或文件夹的名称，不包含上级路径。getPath() //返回绝对路径，可以是相对路径，但是目录要指定getAbsolutePath() //获取文件的绝对路径，与文件是否存在没关系length() // 获取文件的大小（字节数），如果文件不存在则返回0L，如果是文件夹也返回0L。getParent() //返回此抽象路径名父目录的路径名字符串；如果此路径名没有指定父目录，则返回null。lastModified() //获取最后一次被修改的时间。staic File[] listRoots() //列出所有的根目录（Window中就是所有系统的盘符）list() //返回目录下的文件或者目录名，包含隐藏文件。对于文件这样操作会返回null。list(FilenameFilter filter) //返回指定当前目录中符合过滤条件的子文件或子目录。对于文件这样操作会返回null。listFiles() //返回目录下的文件或者目录对象（File类实例），包含隐藏文件。对于文件这样操作会返回null。listFiles(FilenameFilter filter) //返回指定当前目录中符合过滤条件的子文件或子目录。对于文件这样操作会返回null。 路径问题 对于UNIX平台，绝对路径名的前缀是”/“。相对路径名没有前缀。 对于Windows平台，绝对路径名的前缀由驱动器号和一个”:”组成，例”c:\…”。相对路径没有盘符前缀。更专业的做法是使用File.separatorChar或者File.separator（前者为char，后者为String），这个值就会根据系统得到的相应的分割符。 2.常见File类面试题1、File类型中定义了什么方法来创建一级目录1mkdirs() //在指定位置创建目录，这会创建路径中所有不存在的目录。 2、File类型中定义了什么方法来判断一个文件是否存在1exists() //文件或文件夹是否存在。 3、如何用Java代码列出一个目录下所有的文件？1234567891011121314151617181920212223242526272829303132333435//只查询当前目录public class Main &#123; public static void main(String[] args) &#123; File f = new File("d:"); for(File temp : f.listFiles()) &#123; if(temp.isFile()) &#123; System.out.println(temp.getName()); &#125; &#125; &#125;&#125;// 如果需要对文件夹继续展开 public static void main(String[] args) &#123; showDirectory(new File("d:\\file")); &#125; public static void showDirectory(File f) &#123; _walkDirectory(f, 0); &#125; private static void _walkDirectory(File f, int level) &#123; if(f.isDirectory()) &#123; for(File temp : f.listFiles()) &#123; _walkDirectory(temp, level + 1); &#125; &#125; else &#123; for(int i = 0; i &lt; level - 1; i++) &#123; System.out.print("\t"); &#125; System.out.println(f.getName()); &#125; &#125; 在Java 7中可以使用NIO.2的API来做同样的事情，代码如下所示：12345678910111213public static void main(String[] args) throws IOException &#123; Path initPath = Paths.get("/Users/Hao/Downloads"); Files.walkFileTree(initPath, new SimpleFileVisitor&lt;Path&gt;() &#123; @Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException &#123; System.out.println(file.getFileName().toString()); return FileVisitResult.CONTINUE; &#125; &#125;); &#125;]]></content>
      <categories>
        <category>Java IO</category>
      </categories>
      <tags>
        <tag>Interview</tag>
        <tag>java</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程从入门到放弃【4】]]></title>
    <url>%2F2018%2F05%2F20%2Fjava%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93%E7%AF%874%E2%80%94%E2%80%94%E9%94%81%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[在开发Java多线程应用程序中，各个线程之间由于要共享资源，必须用到锁机制。Java提供了多种多线程锁机制的实现方式，常见的有·synchronized、ReentrantLock、Semaphore、AtomicInteger·等。每种机制都有优缺点与各自的适用场景，必须熟练掌握他们的特点才能在Java多线程应用开发时得心应手。——《Java锁机制详解》。线程同步有关的类图关系可用以下的图总结： 1、Java Concurrency API 中的 Lock接口是什么？对比同步它有什么优势？Lock接口比同步方法和同步块（这里的同步就是考察Synchronized关键字）提供了更具扩展性的锁操作。如果一个代码块被synchronized修饰了，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里获取锁的线程释放锁只会有两种情况： 获取锁的线程执行完了该代码块，然后线程释放对锁的占有； 线程执行发生异常，此时JVM会让线程自动释放锁。 那么如果这个获取锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，其他线程便只能阻塞等待，非常影响效率。因此就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间或者能够响应中断），通过Lock就可以办到。 再举个例子：当有多个线程读写文件时，读操作和写操作会发生冲突现象，写操作和写操作会发生冲突现象，但是读操作和读操作不会发生冲突现象。但是采用synchronized关键字来实现同步的话，就会导致一个问题：如果多个线程都只是进行读操作，所以当一个线程在进行读操作时，其他线程只能等待无法进行读操作。因此就需要一种机制来使得多个线程都只是进行读操作时，线程之间不会发生冲突，通过Lock就可以办到。 Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性，Lock是一个类，通过这个类可以实现同步访问；他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。它的优势有：可以使锁更公平；可以使线程在等待锁的时候响应中断；可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间；可以在不同的范围，以不同的顺序获取和释放锁。 关于API及代码的例子请移步：《java并发编程Lock》。常用接口方法如下：12345678public interface Lock &#123; void lock(); void lockInterruptibly() throws InterruptedException; boolean tryLock(); boolean tryLock(long time, TimeUnit unit) throws InterruptedException; void unlock(); Condition newCondition();&#125; 首先lock()方法是平常使用得最多的一个方法，就是用来获取锁。如果锁已被其他线程获取，则进行等待。由于在前面讲到如果采用Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁。因此一般来说，使用Lock必须在try{}catch{}块中进行，并且将释放锁的操作放在finally块中进行，以保证锁一定被被释放，防止死锁的发生。通常使用Lock来进行同步的话，是以下面这种形式去使用的：123456789Lock lock = ...;lock.lock();try&#123; //处理任务&#125;catch(Exception ex)&#123;&#125;finally&#123; lock.unlock(); //释放锁&#125; tryLock()方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。tryLock(long time, TimeUnit unit)方法和tryLock()方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。123456789101112Lock lock = ...;if(lock.tryLock()) &#123; try&#123; //处理任务 &#125;catch(Exception ex)&#123; &#125;finally&#123; lock.unlock(); //释放锁 &#125;&#125;else &#123; //如果不能获取锁，则直接做其他事情&#125; lockInterruptibly()方法比较特殊，当通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。也就使说，当两个线程同时通过lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。由于lockInterruptibly()的声明中抛出了异常，所以lock.lockInterruptibly()必须放在try块中或者在调用lockInterruptibly()的方法外声明抛出InterruptedException。12345678public void method() throws InterruptedException &#123; lock.lockInterruptibly(); try &#123; //..... &#125; finally &#123; lock.unlock(); &#125; ReentrantLock，意思是“可重入锁”，ReentrantLock是唯一实现了Lock接口的类，并且ReentrantLock提供了更多的方法。以下给出一个ReentrantLock的运行实例：12345678910111213141516171819202122232425262728293031323334public class Test &#123; private ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(); private Lock lock = new ReentrantLock(); //注意这个地方，声明为类的属性 public static void main(String[] args) &#123; final Test test = new Test(); new Thread()&#123; public void run() &#123; test.insert(Thread.currentThread()); &#125;; &#125;.start(); //可以用Java箭头函数特性改写上述冗余代码： // new Thread()&#123;()-&gt;Thread.currentThread&#125;.start(); new Thread()&#123; public void run() &#123; test.insert(Thread.currentThread()); &#125;; &#125;.start(); &#125; public void insert(Thread thread) &#123; lock.lock(); try &#123; System.out.println(thread.getName()+"得到了锁"); for(int i=0;i&lt;5;i++) &#123; arrayList.add(i); &#125; &#125; catch (Exception e) &#123; // TODO: handle exception &#125;finally &#123; System.out.println(thread.getName()+"释放了锁"); lock.unlock(); &#125; &#125; 上文中提到了Lock接口以及对象，使用它，很优雅的控制了竞争资源的安全访问，但是这种锁不区分读写，称这种锁为普通锁。为了提高性能，Java提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果没有写锁的情况下，读是无阻塞的,在一定程度上提高了程序的执行效率。Java中读写锁有个接口java.util.concurrent.locks. ReadWriteLock，也有具体的实现ReentrantReadWriteLock，因而会有下面的提问： 2、ReadWriteLock是什么？当有写线程时，则写线程独占同步状态，当没有写线程时只有读线程时，则多个读线程可以共享同步状态。读写锁就是为了实现这种效果而生。 读写锁：分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由jvm自己控制的，我们只要上好相应的锁即可。如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁；如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上读锁，写的时候上写锁！读写锁接口：ReadWriteLock，它的具体实现类为：ReentrantReadWriteLock。《ReadWriteLock场景应用》：在多线程的环境下，对同一份数据进行读写，会涉及到线程安全的问题。比如在一个线程读取数据的时候，另外一个线程在写数据，而导致前后数据的不一致性；一个线程在写数据的时候，另一个线程也在写，同样也会导致线程前后看到的数据的不一致性。这时候可以在读写方法中加入互斥锁，任何时候只能允许一个线程的一个读或写操作，而不允许其他线程的读或写操作，这样是可以解决这样以上的问题，但是效率却大打折扣了。因为在真实的业务场景中，一份数据，读取数据的操作次数通常高于写入数据的操作，而线程与线程间的读读操作是不涉及到线程安全的问题，没有必要加入互斥锁，只要在读-写，写-写期间上锁就行了。API调用请移步 构造了一个线程安全的缓存，先创建一个ReentrantReadWriteLock对象，构造函数 false 代表是非公平的（非公平的含义和ReentrantLock相同）。然后通过readLock、writeLock方法分别获取读锁和写锁。在做读操作的时候，也就是get方法，我们要先获取读锁；在做写操作的时候，即put方法，我们要先获取写锁。123456789101112131415161718192021222324public class ReadWriteCache &#123; private static Map&lt;String, Object&gt; data = new HashMap&lt;&gt;(); private static ReadWriteLock lock = new ReentrantReadWriteLock(false); private static Lock rlock = lock.readLock(); private static Lock wlock = lock.writeLock(); public static Object get(String key) &#123; rlock.lock(); try &#123; return data.get(key); &#125; finally &#123; rlock.unlock(); &#125; &#125; public static Object put(String key, Object value) &#123; wlock.lock(); try &#123; return data.put(key, value); &#125; finally &#123; wlock.unlock(); &#125; &#125;&#125; 3、锁机制有什么用有些业务逻辑在执行过程中要求对数据进行排他性的访问，于是需要通过一些机制保证在此过程中数据被锁住不会被外界修改，这就是所谓的锁机制。 4、什么是乐观锁（Optimistic Locking）？如何实现乐观锁？如何避免ABA问题悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。 乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。 5、解释以下名词：重排序，自旋锁，偏向锁，轻量级锁，可重入锁，公平锁，非公平锁，乐观锁，悲观锁重入锁（ReentrantLock）是一种递归无阻塞的同步机制。重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。在JAVA环境下 ReentrantLock 和synchronized都是 可重入锁。 自旋锁，由于自旋锁使用者一般保持锁时间非常短，因此选择自旋而不是睡眠是非常必要的，自旋锁的效率远高于互斥锁。如何旋转呢？何为自旋锁，就是如果发现锁定了，不是睡眠等待，而是采用让当前线程不停地的在循环体内执行实现的，当循环的条件被其他线程改变时 才能进入临界区。 偏向锁(Biased Locking)是Java6引入的一项多线程优化，它会偏向于第一个访问锁的线程，如果在运行过程中，同步锁只有一个线程访问，不存在多线程争用的情况，则线程是不需要触发同步的，这种情况下，就会给线程加一个偏向锁。 如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会消除它身上的偏向锁，将锁恢复到标准的轻量级锁。 轻量级锁是由偏向所升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁。 重入锁（ReentrantLock）是一种递归无阻塞的同步机制，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。 在JAVA环境下 ReentrantLock 和synchronized都是 可重入锁。 公平锁，就是很公平，在并发环境中，每个线程在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程线程是等待队列的第一个，就占有锁，否则就会加入到等待队列中，以后会按照FIFO的规则从队列中取到自己 非公平锁比较粗鲁，上来就直接尝试占有锁。在公平的锁上，线程按照他们发出请求的顺序获取锁，但在非公平锁上，则允许‘插队’：当一个线程请求非公平锁时，如果在发出请求的同时该锁变成可用状态，那么这个线程会跳过队列中所有的等待线程而获得锁。 非公平的ReentrantLock 并不提倡 插队行为，但是无法防止某个线程在合适的时候进行插队。 6、什么时候应该使用可重入锁？场景1：如果已加锁，则不再重复加锁。a、忽略重复加锁。b、用在界面交互时点击执行较长时间请求操作时，防止多次点击导致后台重复执行（忽略重复触发）。以上两种情况多用于进行非重要任务防止重复执行，（如：清除无用临时文件，检查某些资源的可用性，数据备份操作等） 场景2：如果发现该操作已经在执行，则尝试等待一段时间，等待超时则不执行（尝试等待执行）这种其实属于场景2的改进，等待获得锁的操作有一个时间的限制，如果超时则放弃执行。用来防止由于资源处理不当长时间占用导致死锁情况（大家都在等待资源，导致线程队列溢出）。 场景3：如果发现该操作已经加锁，则等待一个一个加锁（同步执行，类似synchronized）这种比较常见大家也都在用，主要是防止资源使用冲突，保证同一时间内只有一个操作可以使用该资源。但与synchronized的明显区别是性能优势（伴随jvm的优化这个差距在减小）。同时Lock有更灵活的锁定方式，公平锁与不公平锁，而synchronized永远是公平的。这种情况主要用于对资源的争抢（如：文件操作，同步消息发送，有状态的操作等） 场景4：可中断锁。synchronized与Lock在默认情况下是不会响应中断(interrupt)操作，会继续执行完。lockInterruptibly()提供了可中断锁来解决此问题。（场景3的另一种改进，没有超时，只能等待中断或执行完毕）这种情况主要用于取消某些操作对资源的占用。如：（取消正在同步运行的操作，来防止不正常操作长时间占用造成的阻塞） 7、简述锁的等级方法锁、对象锁、类锁方法锁（synchronized修饰方法时）通过在方法声明中加入 synchronized关键字来声明 synchronized方法。synchronized方法控制对类成员变量的访问： 每个类实例对应一把锁，每个synchronized方法都必须获得调用该方法的类实例的锁方能执行，否则所属线程阻塞，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。这种机制确保了同一时刻对于每一个类实例，其所有声明为 synchronized的成员函数中至多只有一个处于可执行状态，从而有效避免了类成员变量的访问冲突。 对象锁（synchronized修饰方法或代码块）当一个对象中有synchronized method或synchronized block的时候调用此对象的同步方法或进入其同步区域时，就必须先获得对象锁。如果此对象的对象锁已被其他调用者占用，则需要等待此锁被释放。（方法锁也是对象锁）。java的所有对象都含有1个互斥锁，这个锁由JVM自动获取和释放。线程进入synchronized方法的时候获取该对象的锁，当然如果已经有线程获取了这个对象的锁，那么当前线程会等待；synchronized方法正常返回或者抛异常而终止，JVM会自动释放对象锁。这里也体现了用synchronized来加锁的1个好处，方法抛异常的时候，锁仍然可以由JVM来自动释放。 类锁(synchronized修饰静态的方法或代码块)，由于一个class不论被实例化多少次，其中的静态方法和静态变量在内存中都只有一份。所以，一旦一个静态的方法被申明为synchronized。此类所有的实例化对象在调用此方法，共用同一把锁，我们称之为类锁。对象锁是用来控制实例方法之间的同步，类锁是用来控制静态方法（或静态变量互斥体）之间的同步。类锁只是一个概念上的东西，并不是真实存在的，它只是用来帮助我们理解锁定实例方法和静态方法的区别的。java类可能会有很多个对象，但是只有1个Class对象，也就是说类的不同实例之间共享该类的Class对象。Class对象其实也仅仅是1个java对象，只不过有点特殊而已。由于每个java对象都有1个互斥锁，而类的静态方法是需要Class对象。所以所谓的类锁，不过是Class对象的锁而已。获取类的Class对象有好几种，最简单的就是［类名.class］的方式。 8、Java中活锁和死锁有什么区别？死锁：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。死锁发生的四个条件 1、互斥条件：线程对资源的访问是排他性的，如果一个线程对占用了某资源，那么其他线程必须处于等待状态，直到资源被释放。 2、请求和保持条件：线程T1至少已经保持了一个资源R1占用,但又提出对另一个资源R2请求，而此时，资源R2被其他线程T2占用，于是该线程T1也必须等待，但又对自己保持的资源R1不释放。 3、不剥夺条件：线程已获得的资源，在未使用完之前，不能被其他线程剥夺，只能在使用完以后由自己释放。 4、环路等待条件：在死锁发生时，必然存在一个“进程-资源环形链”，即：{p0,p1,p2,...pn},进程p0（或线程）等待p1占用的资源，p1等待p2占用的资源，pn等待p0占用的资源。（最直观的理解是，p0等待p1占用的资源，而p1而在等待p0占用的资源，于是两个进程就相互等待） 活锁：是指线程1可以使用资源，但它很礼貌，让其他线程先使用资源，线程2也可以使用资源，但它很绅士，也让其他线程先使用资源。这样你让我，我让你，最后两个线程都无法使用资源。 9、如何确保 N 个线程可以访问 N 个资源同时又不导致死锁？预防死锁，预先破坏产生死锁的四个条件。互斥不可能破坏，所以有如下3种方法： 1.破坏，请求和保持条件1.1）进程等所有要请求的资源都空闲时才能申请资源，这种方法会使资源严重浪费（有些资源可能仅在运行初期或结束时才使用，甚至根本不使用）1.2）允许进程获取初期所需资源后，便开始运行，运行过程中再逐步释放自己占有的资源。比如有一个进程的任务是把数据复制到磁盘中再打印，前期只需要获得磁盘资源而不需要获得打印机资源，待复制完毕后再释放掉磁盘资源。这种方法比上一种好，会使资源利用率上升。 2.破坏，不可抢占条件。这种方法代价大，实现复杂 3.破坏，循坏等待条件。对各进程请求资源的顺序做一个规定，避免相互等待。这种方法对资源的利用率比前两种都高，但是前期要为设备指定序号，新设备加入会有一个问题，其次对用户编程也有限制 10、死锁与饥饿的区别？相同点：二者都是由于竞争资源而引起的。 不同点： 从进程状态考虑，死锁进程都处于等待状态，忙等待(处于运行或就绪状态)的进程并非处于等待状态，但却可能被饿死； 死锁进程等待永远不会被释放的资源，饿死进程等待会被释放但却不会分配给自己的资源，表现为等待时限没有上界(排队等待或忙式等待)； 死锁一定发生了循环等待，而饿死则不然。这也表明通过资源分配图可以检测死锁存在与否，但却不能检测是否有进程饿死； 死锁一定涉及多个进程，而饥饿或被饿死的进程可能只有一个。 在饥饿的情形下，系统中有至少一个进程能正常运行，只是饥饿进程得不到执行机会。而死锁则可能会最终使整个系统陷入死锁并崩溃11、怎么检测一个线程是否拥有锁？java.lang.Thread中有一个方法叫holdsLock()，它返回true如果当且仅当当前线程拥有某个具体对象的锁1234567891011121314151617181920Object o = new Object();@Testpublic void test1() throws Exception &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized(o) &#123; System.out.println("child thread: holdLock: " + Thread.holdsLock(o)); &#125; &#125; &#125;).start(); System.out.println("main thread: holdLock: " + Thread.holdsLock(o)); Thread.sleep(2000);&#125; 12main thread: holdLock: falsechild thread: holdLock: true 12、如何实现分布式锁？基于数据库实现分布式锁基于缓存（redis，memcached，tair）实现分布式锁基于Zookeeper实现分布式锁可以参考详情《分布式锁的几种实现方式》 、 《分布式锁的3种方式》 13、有哪些无锁数据结构，他们实现的原理是什么？java 1.5提供了一种无锁队列（wait-free/lock-free）ConcurrentLinkedQueue，可支持多个生产者多个消费者线程的环境：网上别人自己实现的一种无锁算法队列，原理和jdk官方的ConcurrentLinkedQueue相似：通过volatile关键字来保证数据唯一性（注：java的volatile和c++的volatile关键字是两码事！），但是里面又用到atomic，感觉有点boost::lockfree::queue的风格，估计参考了boost的代码来编写这个java无锁队列。 14、Executors类是什么？ Executor和Executors的区别正如上面所说，这三者均是 Executor 框架中的一部分。Java 开发者很有必要学习和理解他们，以便更高效的使用 Java 提供的不同类型的线程池。总结一下这三者间的区别，以便大家更好的理解： Executor和 ExecutorService 这两个接口主要的区别是：ExecutorService 接口继承了Executor 接口，是Executor的子接口Executor和ExecutorService 第二个区别是：Executor接口定义了 execute()方法用来接收一个Runnable接口的对象，而 ExecutorService接口中的 submit()方法可以接受Runnable和Callable接口的对象。Executor 和 ExecutorService 接口第三个区别是Executor中的 execute()方法不返回任何结果，而 ExecutorService中的 submit()方法可以通过一个 Future对象返回运算结果。Executor 和 ExecutorService 接口第四个区别是除了允许客户端提交一个任务，ExecutorService 还提供用来控制线程池的方法。比如：调用 shutDown()方法终止线程池。可以通过 《Java Concurrency in Practice》 一书了解更多关于关闭线程池和如何处理 pending 的任务的知识。Executors 类提供工厂方法用来创建不同类型的线程池。比如: newSingleThreadExecutor() 创建一个只有一个线程的线程池，newFixedThreadPool(int numOfThreads)来创建固定线程数的线程池，newCachedThreadPool()可以根据需要创建新的线程，但如果已有线程是空闲的会重用已有线程。 Executor ExecutorServiceExecutor 是 Java 线程池的核心接口，用来并发执行提交的任务 ExecutorService 是 Executor 接口的扩展，提供了异步执行和关闭线程池的方法提供execute()方法用来提交任务 提供submit()方法用来提交任务execute()方法无返回值 submit()方法返回Future对象，可用来获取任务执行结果不能取消任务 可以通过Future.cancel()取消pending中的任务没有提供和关闭线程池有关的方法 提供了关闭线程池的方法 16、什么是Java线程转储(Thread Dump)，如何得到它？线程转储是一个JVM活动线程的列表，它对于分析系统瓶颈和死锁非常有用。有很多方法可以获取线程转储——使用Profiler，Kill -3命令，jstack工具等等。我更喜欢jstack工具，因为它容易使用并且是JDK自带的。由于它是一个基于终端的工具，所以我们可以编写一些脚本去定时的产生线程转储以待分析。 17、如何在Java中获取线程堆栈？Java虚拟机提供了线程转储（thread dump）的后门，通过这个后门可以把线程堆栈打印出来。通常我们将堆栈信息重定向到一个文件中，便于我们分析，由于信息量太大，很可能超出控制台缓冲区的最大行数限制造成信息丢失。这里介绍一个jdk自带的打印线程堆栈的工具，jstack用于打印出给定的Java进程ID或core file或远程调试服务的Java堆栈信息。（Java问题定位之Java线程堆栈分析）12示例：$jstack –l 23561 &gt;&gt; xxx.dump命令 : $jstack [option] pid &gt;&gt; 文件 表示输出到文件尾部，实际运行中，往往一次dump的信息，还不足以确认问题，建议产生三次dump信息，如果每次dump都指向同一个问题，我们才确定问题的典型性。 18、说出 3 条在 Java 中使用线程的最佳实践给你的线程起个有意义的名字。这样可以方便找bug或追踪。OrderProcessor, QuoteProcessor or TradeProcessor这种名字比Thread-1. Thread-2 and Thread-3好多了，给线程起一个和它要完成的任务相关的名字，所有的主要框架甚至JDK都遵循这个最佳实践。 避免锁定和缩小同步的范围锁花费的代价高昂且上下文切换更耗费时间空间，试试最低限度的使用同步和锁，缩小临界区。因此相对于同步方法我更喜欢同步块，它给我拥有对锁的绝对控制权。 多用同步类少用wait和notify首先，CountDownLatch, Semaphore, CyclicBarrier和Exchanger这些同步类简化了编码操作，而用wait和notify很难实现对复杂控制流的控制。其次，这些类是由最好的企业编写和维护在后续的JDK中它们还会不断优化和完善，使用这些更高等级的同步工具你的程序可以不费吹灰之力获得优化。 多用并发集合少用同步集合，这是另外一个容易遵循且受益巨大的最佳实践，并发集合比同步集合的可扩展性更好，所以在并发编程时使用并发集合效果更好。如果下一次你需要用到map，你应该首先想到用ConcurrentHashMap。 19、【情景开放题】实际项目中使用多线程举例。你在多线程环境中遇到的常见的问题是什么？你是怎么解决它的？请说出与线程同步以及线程调度相关的方法程序中有3个 socket，需要多少个线程来处理假如有一个第三方接口，有很多个线程去调用获取数据，现在规定每秒钟最多有 10 个线程同时调用它，如何做到如何在 Windows 和 Linux 上查找哪个线程使用的 CPU 时间最长如何确保 main() 方法所在的线程是 Java 程序最后结束的线程非常多个线程（可能是不同机器），相互之间需要等待协调才能完成某种工作，问怎么设计这种协调方案你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Interview</tag>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程从入门到放弃【3】]]></title>
    <url>%2F2018%2F05%2F20%2Fjava%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93%E7%AF%873%E4%B9%8B%E2%80%94%E2%80%94%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[线程的生命周期全在一张图中，理解此图是基本： 一、新建和就绪状态当程序使用new关键字创建了一个线程之后，该线程就处于新建状态，此时它和其他的Java对象一样，仅仅由Java虚拟机为其分配内存，并初始化其成员变量的值。此时的线程对象没有表现出任何线程的动态特征，程序也不会执行线程的线程执行体。 当线程对象调用了start()方法之后，该线程处于就绪状态。Java虚拟机会为其创建方法调用栈和程序计数器，处于这个状态中的线程并没有开始运行，只是表示该线程可以运行了。至于该线程何时开始运行，取决于JVM里线程调度器的调度。 注意：启动线程使用start()方法，而不是run()方法。永远不要调用线程对象的run()方法。调用start方法来启动线程，系统会把该run()方法当成线程执行体来处理；但如果直按调用线程对象的run()方法，则run()方法立即就会被执行，而且在run()方法返回之前其他线程无法并发执行。也就是说，系统把线程对象当成一个普通对象，而run()方法也是一个普通方法，而不是线程执行体。需要指出的是，调用了线程的run()方法之后，该线程已经不再处于新建状态，不要再次调用线程对象的start()方法。只能对处于新建状态的线程调用start()方法，否则将引发IllegaIThreadStateExccption异常。调用线程对象的start()方法之后，该线程立即进入就绪状态——就绪状态相当于”等待执行”，但该线程并未真正进入运行状态。如果希望调用子线程的start()方法后子线程立即开始执行，程序可以使用Thread.sleep(1)来让当前运行的线程（主线程）睡眠1毫秒，1毫秒就够了，因为在这1毫秒内CPU不会空闲，它会去执行另一个处于就绪状态的线程，这样就可以让子线程立即开始执行。 二、运行和阻塞状态2.1 线程调度如果处于就绪状态的线程获得了CPU，开始执行run()方法的线程执行体，则该线程处于运行状态，如果计算机只有一个CPU。那么在任何时刻只有一个线程处于运行状态，当然在一个多处理器的机器上，将会有多个线程并行执行；当线程数大于处理器数时，依然会存在多个线程在同一个CPU上轮换的现象。 当一个线程开始运行后，它不可能一直处于运行状态（除非它的线程执行体足够短，瞬间就执行结束了）。线程在运行过程中需要被中断，目的是使其他线程获得执行的机会，线程调度的细节取决于底层平台所采用的策略。对于采用抢占式策略的系统而言，系统会给每个可执行的线程一个小时间段来处理任务；当该时间段用完后，系统就会剥夺该线程所占用的资源，让其他线程获得执行的机会。在选择下一个线程时，系统会考虑线程的优先级。 所有现代的桌面和服务器操作系统都采用抢占式调度策略，但一些小型设备如手机则可能采用协作式调度策略，在这样的系统中，只有当一个线程调用了它的sleep()或yield()方法后才会放弃所占用的资源——也就是必须由该线程主动放弃所占用的资源。 2.2 线程阻塞当发生如下情况时，线程将会进入阻塞状态① 线程调用sleep()方法主动放弃所占用的处理器资源② 线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞③ 线程试图获得一个同步监视器，但该同步监视器正被其他线程所持有。关于同步监视器的知识、后面将存更深入的介绍④ 线程在等待某个通知（notify）⑤ 程序调用了线程的suspend()方法将该线程挂起。但这个方法容易导致死锁，所以应该尽量避免使用该方法 当前正在执行的线程被阻塞之后，其他线程就可以获得执行的机会。被阻塞的线程会在合适的时候重新进入就绪状态，注意是就绪状态而不是运行状态。也就是说，被阻塞线程的阻塞解除后，必须重新等待线程调度器再次调度它。 2.3 解除阻塞针对上面几种情况，当发生如下特定的情况时可以解除上面的阻塞，让该线程重新进入就绪状态：① 调用sleep()方法的线程经过了指定时间。② 线程调用的阻塞式IO方法已经返回。③ 线程成功地获得了试图取得的同步监视器。④ 线程正在等待某个通知时，其他线程发出了个通知。⑤ 处于挂起状态的线程被调甩了resume()恢复方法。线程从阻塞状态只能进入就绪状态，无法直接进入运行状态。而就绪和运行状态之间的转换通常不受程序控制，而是由系统线程调度所决定。当处于就绪状态的线程获得处理器资源时，该线程进入运行状态；当处于运行状态的线程失去处理器资源时，该线程进入就绪状态。但有一个方法例外，调用yield()方法可以让运行状态的线程转入就绪状态。关于yield()方法后面有更详细的介纽。 三、线程死亡3.1 死亡状态线程会以如下3种方式结束，结束后就处于死亡状态：① run()或call()方法执行完成，线程正常结束。② 线程抛出一个未捕获的Exception或Error。③ 直接调用该线程stop()方法来结束该线程——该方法容易导致死锁，通常不推荐使用。 四、重难点考察1. 有哪些不同的线程生命周期？当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，它要经过新建(New)、就绪（Runnable）、运行（Running）、阻塞(Blocked)和死亡(Dead)5种状态。尤其是当线程启动以后，它不可能一直”霸占”着CPU独自运行，所以CPU需要在多条线程之间切换，于是线程状态也会多次在运行、阻塞之间切换 1. 新建状态，当程序使用new关键字创建了一个线程之后，该线程就处于新建状态，此时仅由JVM为其分配内存，并初始化其成员变量的值 2. 就绪状态，当线程对象调用了start()方法之后，该线程处于就绪状态。Java虚拟机会为其创建方法调用栈和程序计数器，等待调度运行 3. 运行状态，如果处于就绪状态的线程获得了CPU，开始执行run()方法的线程执行体，则该线程处于运行状态 4. 阻塞状态，当处于运行状态的线程失去所占用资源之后，便进入阻塞状态. 5. 转换过程, 在线程的生命周期当中，线程的各种状态的转换过程 2.线程状态，BLOCKED 和 WAITING 有什么区别线程可以通过wait,join,LockSupport.park方式进入wating状态，进入wating状态的线程等待唤醒(notify或notifyAll)才有机会获取cpu的时间片段来继续执行。线程的 blocked状态往往是无法进入同步方法/代码块来完成的。这是因为无法获取到与同步方法/代码块相关联的锁。与wating状态相关联的是等待队列，与blocked状态相关的是同步队列，一个线程由等待队列迁移到同步队列时，线程状态将会由wating转化为blocked。可以这样说，blocked状态是处于wating状态的线程重新焕发生命力的必由之路。 不过个人觉得实际上不用可以区分两者, 因为两者都会暂停线程的执行. 两者的区别是: 进入waiting状态是线程主动的, 而进入blocked状态是被动的. 更进一步的说, 进入blocked状态是在同步(synchronized代码之外), 而进入waiting状态是在同步代码之内. 3.ThreadLocal用途是什么，原理是什么，用的时候要注意什么？在多线程程序中，同一个线程在某个时间段只能处理一个任务，我们希望在这个时间段内,任务的某些变量能够和处理它的线程进行绑定，,在任务需要使用这个变量的时候，这个变量能够方便的从线程中取出来。ThreadLocal能很好的满足这个需求，用ThreadLocal变量的程序看起来也会简洁很多，因为减少了变量在程序中的传递，每个运行的线程都会有一个类型为ThreadLocal。ThreadLocalMap的map，这个map就是用来存储与这个线程绑定的变量,map的key就是ThreadLocal对象，value就是线程正在执行的任务中的某个变量的包装类Entry、在使用ThreadLocal对象，尽量使用static，不然会使线程的ThreadLocalMap产生太多Entry，从而造成内存泄露。 4.Java中用到的线程调度算法是什么？5.什么是多线程中的上下文切换？即使是单核CPU也支持多线程执行代码，CPU通过给每个线程分配CPU时间片来实现这个机制。时间片是CPU分配给各个线程的时间，因为时间片非常短，所以CPU通过不停地切换线程执行，让我们感觉多个线程时同时执行的，时间片一般是几十毫秒（ms）。CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再次加载这个任务的状态，从任务保存到再加载的过程就是一次上下文切换。 6、你对线程优先级的理解是什么？每一个线程都是有优先级的, 一般来说, 高优先级的线程在运行时会具有优先权, 但这依赖于线程调度的实现, 这个实现是和操作系统相关的. 我们可以定义线程的优先级getPriority() setPriority(), 但是这并不能保证高优先级的线程会在低优先级的线程前执行. 县城优先级是一个int变量, 1代表最低, 10代表最高。 7、什么是线程调度器 (Thread Scheduler) 和时间分片 (Time Slicing)?线程调度器是一个操作系统服务, 它负责为Runnable状态的线程分配CPU时间, 一旦我们创建一个线程并启动它, 它的执行便依赖于线程调度器的实现。时间分片是指将可用的CPU时间分配给可用的Runnable线程的过程。分配的CPU时间可以基于线程的优先级或者线程的等待时间, 线程调度并不受到Java虚拟机控制, 所以由应用程序来控制它是更好的选择(也就是说不要让你的程序依赖于线程优先级)。 二、线程同步java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时（如数据的增删改查）， 将会导致数据不准确，相互之间产生冲突，因此加入同步锁以避免在该线程没有完成操作之前，被其他线程的调用， 从而保证了该变量的唯一性和准确性。 1、 请说出你所知的线程同步的方法1.同步方法。即有synchronized关键字修饰的方法。 由于java的每个对象都有一个内置锁，当用此关键字修饰方法时， 内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。代码如：12public synchronized void save()&#123;&#125;//注：synchronized关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类 2.同步代码块，即有synchronized关键字修饰的语句块。 被该关键字修饰的语句块会自动被加上内置锁，从而实现同步123//代码如：synchronized(object)&#123;&#125; 注：同步是一种高开销的操作，因此应该尽量减少同步的内容。 通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * 线程同步的运用 */ public class SynchronizedThread &#123; class Bank &#123; private int account = 100; public int getAccount() &#123; return account; &#125; /** * 用同步方法实现 * @param money */ public synchronized void save(int money) &#123; account += money; &#125; /** * 用同步代码块实现 * @param money */ public void save1(int money) &#123; synchronized (this) &#123; account += money; &#125; &#125; &#125; class NewThread implements Runnable &#123; private Bank bank; public NewThread(Bank bank) &#123; this.bank = bank; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; // bank.save1(10); bank.save(10); System.out.println(i + "账户余额为：" + bank.getAccount()); &#125; &#125; &#125; /** * 建立线程，调用内部类 */ public void useThread() &#123; Bank bank = new Bank(); NewThread new_thread = new NewThread(bank); System.out.println("线程1"); Thread thread1 = new Thread(new_thread); thread1.start(); System.out.println("线程2"); Thread thread2 = new Thread(new_thread); thread2.start(); &#125; public static void main(String[] args) &#123; SynchronizedThread st = new SynchronizedThread(); st.useThread(); &#125; &#125; 3.使用特殊域变量(volatile)实现线程同步a.volatile关键字为域变量的访问提供了一种免锁机制，b.使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新，c.因此每次使用该域就要重新计算，而不是使用寄存器中的值d.volatile不会提供任何原子操作，它也不能用来修饰final类型的变量12345678910111213//只给出要修改的代码，其余代码与上同 class Bank &#123; //需要同步的变量加上volatile private volatile int account = 100; public int getAccount() &#123; return account; &#125; //这里不再需要synchronized public void save(int money) &#123; account += money; &#125; ｝ 注：多线程中的非同步问题主要出现在对域的读写上，如果让域自身避免这个问题，则就不需要修改操作该域的方法。 用final域，有锁保护的域和volatile域可以避免非同步的问题。4.使用重入锁实现线程同步，在JavaSE5.0中新增了一个java.util.concurrent包来支持同步。 ReentrantLock类是可重入、互斥、实现了Lock接口的锁， 它与使用synchronized方法和快具有相同的基本行为和语义，并且扩展了其能力ReenreantLock类的常用方法有：123ReentrantLock() : 创建一个ReentrantLock实例lock() : 获得锁unlock() : 释放锁 注：ReentrantLock()还有一个可以创建公平锁的构造方法，但由于能大幅度降低程序运行效率，不推荐使用5.使用局部变量实现线程同步。如果使用ThreadLocal管理变量，则每一个使用该变量的线程都获得该变量的副本， 副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。ThreadLocal 类的常用方法1234ThreadLocal() : 创建一个线程本地变量get() : 返回此线程局部变量的当前线程副本中的值initialValue() : 返回此线程局部变量的当前线程的"初始值"set(T value) : 将此线程局部变量的当前线程副本中的值设置为value 注：ThreadLocal与同步机制：a.ThreadLocal与同步机制都是为了解决多线程中相同变量的访问冲突问题。 b.前者采用以”空间换时间”的方法，后者采用以”时间换空间”的方式 6.使用阻塞队列实现线程同步，7.使用原子变量实现线程同步** 《关于线程同步的7种方式》 2、 synchronized 的原理是什么Synchronized的语义底层是通过一个monitor（监视器锁）来实现的。Synchronized进过编译，会在同步块的前后分别形成monitorenter和monitorexit这个两个字节码指令。在执行monitorenter指令时，首先要尝试获取对象锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象锁，把锁的计算器加1，相应的，在执行monitorexit指令时会将锁计算器就减1，当计算器为0时，锁就被释放了。如果获取对象锁失败，那当前线程就要阻塞，直到对象锁被另一个线程释放为止。 monitorenter ：Each object is associated with a monitor. A monitor is locked if and only if it has an owner. The thread that executes monitorenter attempts to gain ownership of the monitor associated with objectref, as follows:• If the entry count of the monitor associated with objectref is zero, the thread enters the monitor and sets its entry count to one. The thread is then the owner of the monitor.• If the thread already owns the monitor associated with objectref, it reenters the monitor, incrementing its entry count.• If another thread already owns the monitor associated with objectref, the thread blocks until the monitor’s entry count is zero, then tries again to gain ownership. 每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：1、如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。2、如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.3.如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。 monitorexit： The thread that executes monitorexit must be the owner of the monitor associated with the instance referenced by objectref.The thread decrements the entry count of the monitor associated with objectref. If as a result the value of the entry count is zero, the thread exits the monitor and is no longer its owner. Other threads that are blocking to enter the monitor are allowed to attempt to do so. 执行monitorexit的线程必须是objectref所对应的monitor的所有者。指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。 《深入分析Synchronized》 《Java并发编程之——Synchronized》 3、 synchronized 和ReentrantLock有什么不同相似点：这两种同步方式有很多相似之处，它们都是加锁方式同步，而且都是阻塞式的同步，也就是说当如果一个线程获得了对象锁，进入了同步块，其他访问该同步块的线程都必须阻塞在同步块外面等待，而进行线程阻塞和唤醒的代价是比较高的（操作系统需要在用户态与内核态之间来回切换，代价很高，不过可以通过对锁优化进行改善）。 区别：这两种方式最大区别就是对于Synchronized来说，它是java语言的关键字，是原生语法层面的互斥，需要jvm实现。而ReentrantLock它是JDK 1.5之后提供的API层面的互斥锁，需要lock()和unlock()方法配合try/finally语句块来完成。 总的来说，Lock提供了比synchronized更多的功能。但是要注意以下几点： 1）Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问； 2）Lock和synchronized有一点非常大的不同，采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用；而Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁； 3）Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断； 4）通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。 5）Lock可以提高多个线程进行读操作的效率。 在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。 《java两种线程同步方式的区别——Synchronized和ReentrantLock》 4、什么场景下可以使用 volatile 替换 synchronized只需要保证共享资源的可见性的时候可以使用volatile替代，synchronized保证可操作的原子性一致性和可见性。volatile适用于新值不依赖于旧值的情形 5、有T1，T2，T3三个线程，怎么确保它们按顺序执行？怎样保证T2在T1执行完后执行，T3在T2执行完后执行这里考察的主要知识点就是线程同步机制和锁的问题，《Java 指定线程执行顺序（三种方式）》另外关于执行顺序的问题，可以有很多的考察点，可以刷刷这个博客《java指定线程执行的顺序》 6、同步块内的线程抛出异常会发生什么这个问题坑了很多Java程序员，若你能想到锁是否释放这条线索来回答还有点希望答对。无论你的同步块是正常还是异常退出的，里面的线程都会释放锁，所以对比锁接口我更喜欢同步块，因为它不用我花费精力去释放锁，该功能可以在finally block里释放锁实现。 7、当一个线程进入一个对象的synchronized 方法A 之后，其它线程是否可进入此对象的synchronized 方法B不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的synchronized修饰符要求执行方法时要获得对象的锁，如果已经进入A方法说明对象锁已经被取走，那么试图进入B方法的线程就只能在等锁池（注意不是等待池哦 ）中等待对象的锁。 8、使用 synchronized 修饰静态方法和非静态方法有什么区别在static方法前加synchronizedstatic：静态方法属于类方法，它属于这个类，获取到的锁，是属于类的锁。 在普通方法前加synchronizedstatic：非static方法获取到的锁，是属于当前对象的锁。 结论：类锁和对象锁不同，他们之间不会产生互斥。 9、如何从给定集合那里创建一个 synchronized 的集合我们可以使用Collections.synchronizedCollection(Collection c)根据指定集合来获取一个synchronized（线程安全的）集合。比如HashMap可以这样来实现线程安全：1Map m = Collections.synchronizedMap(new HashMap);]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Interview</tag>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程从入门到放弃【2】]]></title>
    <url>%2F2018%2F05%2F20%2Fjava%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93%E7%AF%872%E4%B9%8B%E2%80%94%E2%80%94Thread%E7%B1%BB%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[此片文章主要总结的是Thread类及相关的基础概念和API，首先需要厘清线程调度中的几个基本概念： 一、线程调度的基本方法1、调整线程优先级：Java线程有优先级，优先级高的线程会获得较多的运行机会。Java线程的优先级用整数表示，取值范围是1~10，Thread类有以下三个静态常量：12345static int MAX_PRIORITY //线程可以具有的最高优先级，取值为10。static int MIN_PRIORITY //线程可以具有的最低优先级，取值为1。static int NORM_PRIORITY //分配给线程的默认优先级，取值为5。 Thread类的setPriority()和getPriority()方法分别用来设置和获取线程的优先级。每个线程都有默认的优先级。主线程的默认优先级为Thread.NORM_PRIORITY。线程的优先级有继承关系，比如A线程中创建了B线程，那么B将和A具有相同的优先级。JVM提供了10个线程优先级，但与常见的操作系统都不能很好的映射。如果希望程序能移植到各个操作系统中，应该仅仅使用Thread类有以下三个静态常量作为优先级，这样能保证同样的优先级采用了同样的调度方式。 2、线程睡眠：Thread.sleep(long millis)方法，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。sleep()平台移植性好。 3、线程等待：Object类中的wait()方法，导致当前的线程等待，直到其他线程调用此对象的notify()方法或 notifyAll() 唤醒方法。这个两个唤醒方法也是Object类中的方法，行为等价于调用 wait(0) 一样。 4、线程让步：Thread.yield()方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。 5、线程加入：join()方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。 6、线程唤醒：Object类中的notify()方法，唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait方法，在对象的监视器上等待。 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。类似的方法还有一个notifyAll()，唤醒在此对象监视器上等待的所有线程。 注意：Thread中suspend()和resume()两个方法在JDK1.5中已经废除，不再介绍。因为有死锁倾向。 二、常用函数①sleep(long millis): 在指定的毫秒数内让当前正在执行的线程休眠（暂停执行）②join():指等待t线程终止。join是Thread类的一个方法，启动线程后直接调用，即join()的作用是：“等待该线程终止”，这里需要理解的就是该线程是指的主线程等待子线程的终止。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了才能执行。123Thread t = new AThread();t.start();t.join(); 为什么要用join()方法?在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。123456789101112131415161718192021222324252627282930313233343536373839public class Main2 &#123; public static void main(String[] args) &#123; System.out.println(Thread.currentThread().getName()+"主线程运行开始!"); Thread1 mTh1=new Thread1("A"); Thread1 mTh2=new Thread1("B"); mTh1.start(); mTh2.start(); try &#123; mTh1.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; try &#123; mTh2.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+ "主线程运行结束!"); &#125;&#125;class Thread1 extends Thread&#123; private String name; public Thread1(String name) &#123; super(name); this.name=name; &#125; public void run() &#123; System.out.println(Thread.currentThread().getName() + " 线程运行开始!"); for (int i = 0; i &lt; 5; i++) &#123; System.out.println("子线程"+name + "运行 : " + i); try &#123; sleep((int) Math.random() * 10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(Thread.currentThread().getName() + " 线程运行结束!"); &#125;&#125; 12345678910111213141516main主线程运行开始!A 线程运行开始!B 线程运行开始!子线程A运行 : 0子线程B运行 : 0子线程A运行 : 1子线程A运行 : 2子线程A运行 : 3子线程A运行 : 4A 线程运行结束!子线程B运行 : 1子线程B运行 : 2子线程B运行 : 3子线程B运行 : 4B 线程运行结束!main主线程运行结束! ③yield():暂停当前正在执行的线程对象，并执行其他线程。 Thread.yield()方法作用是：暂停当前正在执行的线程对象，并执行其他线程。yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。 结论：yield()从未导致线程转到等待/睡眠/阻塞状态。在大多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果（注意线程的生命周期）。1234567891011121314151617181920212223public class Main2 &#123; public static void main(String[] args) &#123; ThreadYield yt1 = new ThreadYield("张三"); ThreadYield yt2 = new ThreadYield("李四"); yt1.start(); yt2.start(); &#125;&#125;class ThreadYield extends Thread&#123; public ThreadYield(String name) &#123; super(name); &#125; @Override public void run() &#123; for (int i = 1; i &lt;= 50; i++) &#123; System.out.println("" + this.getName() + "-----" + i); // 当i为30时，该线程就会把CPU时间让掉，让其他或者自己的线程执行（也就是谁先抢到谁执行） if (i ==30) &#123; this.yield(); &#125; &#125; &#125;&#125; 123运行结果：第一种情况：李四（线程）当执行到30时会CPU时间让掉，这时张三（线程）抢到CPU时间并执行。第二种情况：李四（线程）当执行到30时会CPU时间让掉，这时李四（线程）抢到CPU时间并执行。 ④setPriority(): 更改线程的优先级。123MIN_PRIORITY = 1NORM_PRIORITY = 5MAX_PRIORITY = 10 用法：1234Thread4 t1 = new Thread4("t1");Thread4 t2 = new Thread4("t2");t1.setPriority(Thread.MAX_PRIORITY);t2.setPriority(Thread.MIN_PRIORITY); ⑤interrupt():不要以为它是中断某个线程！它只是线线程发送一个中断信号，让线程在无限等待时（如死锁时）能抛出抛出，从而结束线程，但是如果你吃掉了这个异常，那么这个线程还是不会中断的！ ⑥wait()：Obj.wait()，与Obj.notify()必须要与synchronized(Obj)一起使用，也就是wait,与notify是针对已经获取了Obj锁进行操作，从语法角度来说就是Obj.wait(),Obj.notify必须在synchronized(Obj){...}语句块内。从功能上来说wait就是说线程在获取对象锁后，主动释放对象锁，同时本线程休眠。直到有其它线程调用对象的notify()唤醒该线程，才能继续获取对象锁，并继续执行。相应的notify()就是对对象锁的唤醒操作。但有一点需要注意的是notify()调用后，并不是马上就释放对象锁的，而是在相应的synchronized(){}语句块执行结束，自动释放锁后，JVM会在wait()对象锁的线程中随机选取一线程，赋予其对象锁，唤醒线程，继续执行。这样就提供了在线程间同步、唤醒的操作。Thread.sleep()与Object.wait()二者都可以暂停当前线程，释放CPU控制权，主要的区别在于Object.wait()在释放CPU同时，释放了对象锁的控制。 单单在概念上理解清楚了还不够，需要在实际的例子中进行测试才能更好的理解。对Object.wait()，Object.notify()的应用最经典的例子，应该是三线程打印ABC的问题了吧，这是一道比较经典的面试题，题目要求如下：建立三个线程，A线程打印10次A，B线程打印10次B,C线程打印10次C，要求线程同时运行，交替打印10次ABC。这个问题用Object的wait()，notify()就可以很方便的解决。代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class MyThreadPrinter2 implements Runnable &#123; private String name; private Object prev; private Object self; private MyThreadPrinter2(String name, Object prev, Object self) &#123; this.name = name; this.prev = prev; this.self = self; &#125; @Override public void run() &#123; int count = 10; while (count &gt; 0) &#123; synchronized (prev) &#123; synchronized (self) &#123; System.out.print(name); count--; self.notify(); &#125; try &#123; prev.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; public static void main(String[] args) throws Exception &#123; Object a = new Object(); Object b = new Object(); Object c = new Object(); MyThreadPrinter2 pa = new MyThreadPrinter2("A", c, a); MyThreadPrinter2 pb = new MyThreadPrinter2("B", a, b); MyThreadPrinter2 pc = new MyThreadPrinter2("C", b, c); new Thread(pa).start(); Thread.sleep(100); //确保按顺序A、B、C执行 new Thread(pb).start(); Thread.sleep(100); new Thread(pc).start(); Thread.sleep(100); &#125;&#125; 先来解释一下其整体思路，从大的方向上来讲，该问题为三线程间的同步唤醒操作，主要的目的就是ThreadA-&gt;ThreadB-&gt;ThreadC-&gt;ThreadA循环执行三个线程。为了控制线程执行的顺序，那么就必须要确定唤醒、等待的顺序，所以每一个线程必须同时持有两个对象锁，才能继续执行。一个对象锁是prev，就是前一个线程所持有的对象锁。还有一个就是自身对象锁。主要的思想就是，为了控制执行的顺序，必须要先持有prev锁，也就前一个线程要释放自身对象锁，再去申请自身对象锁，两者兼备时打印，之后首先调用self.notify()释放自身对象锁，唤醒下一个等待线程，再调用prev.wait()释放prev对象锁，终止当前线程，等待循环结束后再次被唤醒。运行上述代码，可以发现三个线程循环打印ABC，共10次。程序运行的主要过程就是A线程最先运行，持有C,A对象锁，后释放A,C锁，唤醒B。线程B等待A锁，再申请B锁，后打印B，再释放B，A锁，唤醒C，线程C等待B锁，再申请C锁，后打印C，再释放C,B锁，唤醒A。看起来似乎没什么问题，但如果你仔细想一下，就会发现有问题，就是初始条件，三个线程按照A,B,C的顺序来启动，按照前面的思考，A唤醒B，B唤醒C，C再唤醒A。但是这种假设依赖于JVM中线程调度、执行的顺序。 三、深入考察及疑难点1、启动一个线程是调用 run() 还是 start() 方法？start() 和 run() 方法有什么区别相当于玩游戏机，只有一个游戏机（cpu），可是有很多人要玩，于是，start是排队！等CPU选中你就是轮到你，你就run（），当CPU的运行的时间片执行完，这个线程就继续排队，等待下一次的run（）。调用start（）后，线程会被放到等待队列，等待CPU调度，并不一定要马上开始执行，只是将这个线程置于可动行状态。然后通过JVM，线程Thread会调用run（）方法，执行本线程的线程体。先调用start后调用run，这么麻烦，为了不直接调用run？就是为了实现多线程的优点，没这个start不行。 （1）.start（）方法来启动线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码；通过调用Thread类的start()方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行操作的， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。 （2）.run（）方法当作普通方法的方式调用。程序还是要顺序执行，要等待run方法体执行完毕后，才可继续执行下面的代码； 程序中只有主线程——这一个线程， 其程序执行路径还是只有一条， 这样就没有达到写线程的目的。记住：多线程就是分时利用CPU，宏观上让所有线程一起执行 ，也叫并发 start() :它的作用是启动一个新线程，新线程处于就绪状态，拿到cpu执行权就会执行相应的run()方法。start()不能被重复调用。run(): run()就和普通的成员方法一样，可以被重复调用。单独调用run()的话，会在当前线程中执行run()，而并不会启动新线程！（为什么不直接调用run方法的原因也在此。） 2、sleep() 方法和对象的 wait() 方法都可以让线程暂停执行，它们有什么区别？sleep（）方法sleep()使当前线程进入停滞状态（阻塞当前线程），让出CUP的使用、目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会;sleep()是Thread类的Static(静态)的方法；因此他不能改变对象的机锁，所以当在一个Synchronized块中调用Sleep()方法是，线程虽然休眠了，但是对象的机锁并木有被释放，其他线程无法访问这个对象（即使睡着也持有对象锁）。在sleep()休眠时间期满后，该线程不一定会立即执行，这是因为其它线程可能正在运行而且没有被调度为放弃执行，除非此线程具有更高的优先级。 wait（）方法wait()方法是Object类里的方法；当一个线程执行到wait()方法时，它就进入到一个和该对象相关的等待池中，同时失去（释放）了对象的机锁（暂时失去机锁，wait(long timeout)超时时间到后还需要返还对象锁）；其他线程可以访问；wait()使用notify或者notifyAlll或者指定睡眠时间来唤醒当前等待池中的线程。wiat()必须放在synchronized block中，否则会在program runtime时扔出”java.lang.IllegalMonitorStateException“异常。共同点： 他们都是在多线程的环境下，都可以在程序的调用处阻塞指定的毫秒数，并返回。 wait()和sleep()都可以通过interrupt()方法 打断线程的暂停状态，从而使线程立刻抛出InterruptedException。 如果线程A希望立即结束线程B，则可以对线程B对应的Thread实例调用interrupt方法。如果此刻线程B正在wait/sleep /join，则线程B会立刻抛出InterruptedException，在catch() {} 中直接return即可安全地结束线程。 需要注意的是，InterruptedException是线程自己从内部抛出的，并不是interrupt()方法抛出的。对某一线程调用 interrupt()时，如果该线程正在执行普通的代码，那么该线程根本就不会抛出InterruptedException。但是，一旦该线程进入到 wait()/sleep()/join()后，就会立刻抛出InterruptedException 。 不同点： Thread类的方法：sleep(),yield()等。Object的方法：wait()和notify()等 每个对象都有一个锁来控制同步访问。Synchronized关键字可以和对象的锁交互，来实现线程的同步。sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。 wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用 sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常 所以sleep()和wait()方法的最大区别是：sleep()睡眠时，保持对象锁，仍然占有该锁；而wait()睡眠时，释放对象锁。但是wait()和sleep()都可以通过interrupt()方法打断线程的暂停状态，从而使线程立刻抛出InterruptedException（但不建议使用该方法）。 3、yield方法有什么作用？sleep() 方法和 yield()方法有什么区别?sleep()和yield()的区别:sleep()使当前线程进入停滞状态，所以执行sleep()的线程在指定的时间内肯定不会被执行；yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。 sleep 方法使当前运行中的线程睡眼一段时间，进入不可运行状态，这段时间的长短是由程序设定的，yield 方法使当前线程让出 CPU 占有权，但让出的时间是不可设定的。实际上，yield()方法对应了如下操作：先检测当前是否有相同优先级的线程处于同可运行状态，如有，则把 CPU 的占有权交给此线程，否则，继续运行原来的线程。所以yield()方法称为“退让”，它把运行机会让给了同等优先级的其他线程 另外，sleep 方法允许较低优先级的线程获得运行机会，但 yield() 方法执行时，当前线程仍处在可运行状态，所以，不可能让出较低优先级的线程些时获得 CPU 占有权。在一个运行系统中，如果较高优先级的线程没有调用 sleep 方法，又没有受到 I\O 阻塞，那么，较低优先级线程只能等待所有较高优先级的线程运行结束，才有机会运行。 4、Java 中如何停止一个线程？**停止一个线程意味着在任务处理完任务之前停掉正在做的操作，也就是放弃当前的操作。停止一个线程可以用Thread.stop()方法，但最好不要用它。虽然它确实可以停止一个正在运行的线程，但是这个方法是不安全的，而且是已被废弃的方法。在java中有以下3种方法可以终止正在运行的线程：1.使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。2.使用stop方法强行终止，但是不推荐这个方法，因为stop和suspend及resume一样都是过期作废的方法。3.使用interrupt方法中断线程。具体案例和api可以参考文章《java多线程之——interrupt深入研究》。 5、stop()和 suspend()方法为何不推荐使用?Stop()方法作为一种粗暴的线程终止行为，在线程终止之前没有对其做任何的清除操作，因此具有固有的不安全性。 用Thread.stop()方法来终止线程将会释放该线程对象已经锁定的所有监视器。如果以前受这些监视器保护的任何对象都处于不连贯状态，那么损坏的对象对其他线程可见，这有可能导致不安全的操作。 由于上述原因，因此不应该使用stop()方法，而应该在自己的Thread类中置入一个标志，用于控制目标线程是活动还是停止。如果该标志指示它要停止运行，可使其结束run（）方法。如果目标线程等待很长时间，则应使用interrupt()方法来中断该等待。 suspend()方法 该方法已经遭到反对，因为它具有固有的死锁倾向。调用suspend（）方法的时候，目标线程会停下来。如果目标线程挂起时在保护关键系统资源的监视器上保持有锁，则在目标线程重新开始以前，其他线程都不能访问该资源。除非被挂起的线程恢复运行。对任何其他线程来说，如果想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。由于上述原因，因此不应该使用suspend（）方法，而应在自己的thread类中置入一个标志，用于控制线程是活动还是挂起。如果标志指出线程应该挂起，那么用wait（）方法命令其进入等待状态。如果标志指出线程应当恢复，那么用notify()方法重新启动线程。 6、如何在两个线程间共享数据?通过在线程之间共享对象就可以了，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的。 7、强制启动一个线程？ 实现Runnable接口优势：1）适合多个相同的程序代码的线程去处理同一个资源。2）可以避免java中的单继承的限制。3）增加程序的健壮性，代码可以被多个线程共享，代码和数据独立。 继承Thread类优势：1）可以将线程类抽象出来，当需要使用抽象工厂模式设计时。2）多线程同步 在函数体使用1）无需继承thread或者实现Runnable，缩小作用域。8、如何让正在运行的线程暂停一段时间1、sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态，请参考第66题中的线程状态转换图）。2、wait()是Object类的方法，调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lockpool），如果线程重新获得对象的锁就可以进入就绪状态9、什么是线程组，为什么在Java中不推荐使用？ThreadGroup是一个类, 它的目的是提供关于线程组的信息.ThreadGroupAPI比较薄弱, 它并没有为Thread提供了更多的功能. 它主要有两个功能: 一是获取线程组中处于活跃状态线程的列表; 二是甚至为线程设置未捕获异常处理器(uncaught exception handler) . 但在java 1.5中Thread类也添加了setUncaughtExceptionHandler(UncaughtExceptionHandler eh)方法, 所以ThreadGroup是已经过时的, 不建议使用.10、你是如何调用 wait（方法的）？使用 if 块还是循环？为什么 wait() 方法应该在循环调用，因为当线程获取到 CPU 开始执行的时候，其他条件可能还没有满足，所以在处理前，循环检测条件是否满足会更好。]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Interview</tag>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程从入门到放弃【1】]]></title>
    <url>%2F2018%2F05%2F20%2Fjava%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93%E7%AF%871%E4%B9%8B%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[1、什么是线程进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1–n个线程。（进程是资源分配的最小单位）线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。（线程是cpu调度的最小单位） 2、为什么要使用多线程？或者说使用多线程的好处（1）发挥多核CPU的优势随着工业的进步，现在的笔记本、台式机乃至商用的应用服务器至少也都是双核的，4核、8核甚至16核的也都不少见，如果是单线程的程序，那么在双核CPU上就浪费了50%，在4核CPU上就浪费了75%。单核CPU上所谓的”多线程”那是假的多线程，同一时间处理器只会处理一段逻辑，只不过线程之间切换得比较快，看着像多个线程”同时”运行罢了。多核CPU上的多线程才是真正的多线程，它能让你的多段逻辑同时工作，多线程，可以真正发挥出多核CPU的优势来，达到充分利用CPU的目的。（2）防止阻塞从程序运行效率的角度来看，单核CPU不但不会发挥出多线程的优势，反而会因为在单核CPU上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核CPU我们还是要应用多线程，就是为了防止阻塞。试想，如果单核CPU使用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止运行了。多线程可以防止这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行。（3）便于建模这是另外一个没有这么明显的优点了。假设有一个大的任务A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务A分解成几个小任务，任务B、任务C、任务D，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。 3、多线程的几种实现方式？（1）继承Thread类（2）实现Runnable接口12345678910111213141516171819202122232425//继承Thread类class Thread1 extends Thread&#123; private String name; public Thread1(String name) &#123; this.name=name; &#125; public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(name + "运行 : " + i); try &#123; sleep((int) Math.random() * 10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; Thread1 mTh1=new Thread1("A"); Thread1 mTh2=new Thread1("B"); mTh1.start(); mTh2.start(); &#125;&#125; 说明：程序启动运行main时候，java虚拟机启动一个进程，主线程main在main()调用时候被创建。随着调用两个对象的start方法，另外两个线程也启动了，这样，整个应用就在多线程下运行。 注意：start()方法的调用后并不是立即执行多线程代码，而是使得该线程变为可运行态（Runnable），什么时候运行是由操作系统决定的。从程序运行的结果可以发现，多线程程序是乱序执行。因此，只有乱序执行的代码才有必要设计为多线程。Thread.sleep()方法调用目的是不让当前线程独自霸占该进程所获取的CPU资源，以留出一定时间给其他线程执行的机会。实际上所有的多线程代码执行顺序都是不确定的，每次执行的结果都是随机的。 实现接口的方式比继承类的方式更灵活，也能减少程序之间的耦合度，面向接口编程也是设计模式6大原则的核心。1234567891011121314151617181920212223242526//实现Runnable接口class Thread2 implements Runnable&#123; private String name; public Thread2(String name) &#123; this.name=name; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(name + "运行 : " + i); try &#123; Thread.sleep((int) Math.random() * 10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; new Thread(new Thread2("C")).start(); new Thread(new Thread2("D")).start(); &#125;&#125; 说明：Thread2类通过实现Runnable接口，使得该类有了多线程类的特征。run（）方法是多线程程序的一个约定。所有的多线程代码都在run方法里面。Thread类实际上也是实现了Runnable接口的类。在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target)构造出对象，然后调用Thread对象的start()方法来运行多线程代码。实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是扩展Thread类还是实现Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程编程的基础。 4、用Thread和Runnable哪种方式更好？区别是什么？显然是用Runnable更好，实现Runnable接口比继承Thread类所具有的优势：1）：适合多个相同的程序代码的线程去处理同一个资源2）：可以避免java中的单继承的限制3）：增加程序的健壮性，代码可以被多个线程共享，代码和数据独立4）：线程池只能放入实现Runable或callable类线程，不能直接放入继承Thread的类 5、什么是线程安全？线程安全就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。线程不安全就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据还有一种通俗的解释：如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。这个问题有值得一提的地方，就是线程安全也是有几个级别的：（1）不可变像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用（2）绝对线程安全不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet（3）相对线程安全相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是fail-fast机制。（4）线程非安全这个就没什么好说的了，ArrayList、LinkedList、HashMap等都是线程非安全的类. 6、Vector, SimpleDateFormat是线程安全类吗？SimpleDateFormate不是线程安全的，如果我们把SimpleDateFormat定义成static成员变量，那么多个thread之间会共享这个sdf对象， 所以Calendar对象也会共享。假定线程A和线程B都进入了parse(text, pos)方法， 线程B执行到calendar.clear()后，线程A执行到calendar.getTime(), 那么就会有问题。 Vector 在方法上使用同步这样做本身没有解决多线程问题，反而，在引入了概念的混乱的同时，导致性能问题，因为 synchronized 的开销是巨大的：阻止编译器乱序 。详情请看《Vector是线程安全吗？》。看下面Vector代码就知道了：1234if (!vector.contains(element)) vector.add(element); ...&#125; 这是经典的 put-if-absent 情况，尽管contains, add方法都正确地同步了，但作为 vector之外的使用环境，仍然存在 race condition: 因为虽然条件判断if (!vector.contains(element))与方法调用 vector.add(element); 都是原子性的操作 (atomic)，但在 if 条件判断为真后，那个用来访问vector.contains方法的锁已经释放，在即将的 vector.add方法调用 之间有间隙，在多线程环境中，完全有可能被其他线程获得 vector的 lock并改变其状态, 此时当前线程的vector.add(element); 正在等待（只不过我们不知道而已）。只有当其他线程释放了 vector 的 lock 后，vector.add(element); 继续，但此时它已经基于一个错误的假设了。单个的方法synchronized 了并不代表组合（compound）的方法调用具有原子性，使 compound actions成为线程安全的可能解决办法之一还是离不开intrinsic lock(这个锁应该是 vector的，但由 client 维护)：12345678910// Vector v = ... public boolean putIfAbsent(E x) &#123; synchronized(v) &#123; boolean absent = !contains(x); if (absent) &#123; add(x); &#125; &#125; return absent; &#125; 所以，正确地回答那个“愚蠢”的问题是：Vector 和 ArrayList 实现了同一接口 List, 但所有的 Vector 的方法都具有 synchronized 关键修饰。但对于复合操作，Vector仍然需要进行同步处理。 7、什么 Java 原型不是线程安全的？8、哪些集合类是线程安全的？1.在Map类中，提供两种线程安全容器。(1)java.util.HashtableHashtable和HashMap类似，都是散列表，存储键值对映射。主要区别在于Hashtable是线程安全的。当我们查看Hashtable源码的时候，可以看到Hashtable的方法都是通过synchronized来进行方法层次的同步，以达到线程安全的作用。(2)java.util.concurrent.ConcurrentHashMapConcurrentHashMap是性能更好的散列表。在兼顾线程安全的同时，相对于Hashtable，在效率上有很大的提高。我们可以猜想，Hashtable的线程安全实现是对方法进行synchronized，很明显可以通过其他并发方式，如ReentrantLock进行优化。而ConcurrentHashMap正是采用了ReentrantLock。运用锁分离技术，即在代码块上加锁，而不是方法上加。同时ConcurrentHashMap的一个特色是允许多个修改并发操作。这就有意思了，我们知道一般写都是互斥的，为什么这个还能多个同时写呢？那是因为ConcurrentHashMap采用了内部使用段机制，将ConcurrentHashMap分成了很多小段。只要不在一个小段上写就可以并发写 2.Collection部分主要是运用的CopyOnWrite机制，即写时复制机制。从字面上就能理解什么意思，就是当我们往一个容器里添加元素的时候，先对这个容器进行一次复制，对副本进行写操作。写操作结束后，将原容器的引用指向新副本容器，就完成了写的刷新。从它的实现原理，我们可以看出这种机制是存在缺点的。(1).内存占用：毫无疑问，每次写时需要首先复制一遍原容器，假如复制了很多，或者本身原容器就比较大，那么肯定会占用很多内存。可以采用压缩容器中的元素来防止内存消耗过大。(2).数据一致性问题：当我们在副本中进行写操组时，只能在最终结束后使数据同步，不能实时同步可以看到，这种机制适用于读操作多，写操作少的应用场景。 java.util.concurrent.CopyOnWriteArrayListCollection类的线程安全容器主要都是利用的ReentrantLock实现的线程安全，CopyOnWriteArrayList也不例外。在并发写的时候，需要获取lock。读的时候不需要进行lock java.util.concurrent.CopyOnWriteArraySetCopyOnWriteArraySet的实现就是基于CopyOnWriteArrayList实现的，采用的装饰器进行实现。二者的区别和List和Set的区别一样。 Vector一般我们都不用Vector了，不过它确实也是线程安全的。相对于其他容器，能够提供随机访问功能。9、多线程中的忙循环是什么?忙循环就是程序员用循环让一个线程等待，不像传统方法wait(), sleep()或 yield()它们都放弃了CPU控制，而忙循环不会放弃CPU，它就是在运行一个空循环。这么做的目的是为了保留CPU缓存，在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了。 10、什么是线程局部变量ThreadLocal，很多地方叫做线程本地变量，也有些地方叫做线程本地存储。变量值的共享可以使用public static变量的形式，所有的线程都使用同一个public static变量，但是如果每一个线程都有自己的变量该如何共享呢，就是通过ThreadLocal，ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。最常见的ThreadLocal使用场景为 用来解决 数据库连接、Session管理等。譬如在数据库链接的时候可以这样实现：123456789101112131415161718192021class ConnectionManager &#123; private Connection connect = null; public Connection openConnection() &#123; if(connect == null)&#123; connect = DriverManager.getConnection(); &#125; return connect; &#125; public void closeConnection() &#123; if(connect!=null) connect.close(); &#125;&#125;class Dao&#123; public void insert() &#123; ConnectionManager connectionManager = new ConnectionManager(); Connection connection = connectionManager.openConnection(); //使用connection进行操作 connectionManager.closeConnection(); &#125;&#125; 每次都是在方法内部创建的连接，那么线程之间避免了线程安全问题。但是这样会有一个致命的影响：导致服务器压力非常大，并且严重影响程序执行性能。由于在方法中需要频繁地开启和关闭数据库连接，这样不尽严重影响程序执行效率，还可能导致服务器压力巨大。 那么这种情况下使用ThreadLocal是再适合不过的了，因为ThreadLocal在每个线程中对该变量会创建一个副本，即每个线程内部都会有一个该变量，且在线程内部任何地方都可以使用，线程之间互不影响，这样一来就不存在线程安全问题，也不会严重影响程序执行性能。但是要注意，虽然ThreadLocal能够解决上面说的问题，但是由于在每个线程中都创建了副本，所以要考虑它对资源的消耗，比如内存的占用会比不使用ThreadLocal要大。关于ThreadLocal的API：12345//关于ThreadLocal的API：public T get() &#123; &#125;public void set(T value) &#123; &#125;public void remove() &#123; &#125;protected T initialValue() &#123; &#125; get()方法是用来获取ThreadLocal在当前线程中保存的变量副本，set()用来设置当前线程中变量的副本，remove()用来移除当前线程中变量的副本，initialValue()是一个protected方法，一般是用来在使用时进行重写的，它是一个延迟加载方法。这部分可以网上参考：《Java并发编程：深入剖析ThreadLocal》 ，往上关于此部分知识的有几篇高访问量博文都有争议，切勿照搬，可看评论区。 11、线程和进程有什么区别？进程间如何通讯，线程间如何通讯进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1–n个线程。（进程是资源分配的最小单位）线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。（线程是cpu调度的最小单位）一、进程间的通讯管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。有名管道 (namedpipe)： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。信号量(semophore )： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。消息队列( messagequeue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。信号： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。共享内存(shared memory )：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。套接字(socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。 二、线程间的通信方式锁机制：包括互斥锁、条件变量、读写锁互斥锁提供了以排他方式防止数据结构被并发修改的方法。读写锁允许多个线程同时读共享数据，而对写操作是互斥的。条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量信号机制(Signal)：类似进程间的信号处理线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。有名管道 (namedpipe)： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。信号量(semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。消息队列( messagequeue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。信号 (sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。共享内存(shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。套接字(socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。 12、什么是多线程环境下的伪共享（false sharing）共享就是一个内存区域的数据被多个处理器访问，伪共享就是不是真的共享。这里的共享这个概念是基于逻辑层面的。实际上伪共享与共享在cache line 上实际都是共享的。CPU访问的数据都是从cache line中读取的。如果cpu 在cache 中找不到需要的变量，则称缓存未命中。未命中时，需要通过总线从内存中读取进cache 中。每次读取的内存大小就是一个cache line 的大小。如果多个CPU访问的不同内存变量被装载到了同一个cache line 中，则从程序逻辑层上讲，并没有共享变量，但实际上在cache line 上他们是共享访问的，这个就是典型的伪共享。伪共享与共享 在 cache line 的层面上必须都是共享的。多个CPU对共享内存的访问安全通过缓存一致性来保证。伪共享问题很难被发现，因为线程可能访问完全不同的全局变量，内存中却碰巧在很相近的位置上。如其他诸多的并发问题，避免伪共享的最基本方式是仔细审查代码，根据缓存行来调整你的数据结构。 13、同步和异步有何异同，在什么情况下分别使用他们？举例说明如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。Java中交互方式分为同步和异步两种： 同步交互：指发送一个请求,需要等待返回,然后才能够发送下一个请求，有个等待过程； 异步交互：指发送一个请求,不需要等待返回,随时可以再发送下一个请求，即不需要等待。 区别：一个需要等待，一个不需要等待，在部分情况下，我们的项目开发中都会优先选择不需要等待的异步交互方式。哪些情况建议使用同步交互呢？比如银行的转账系统，对数据库的保存操作等等，都会使用同步交互操作，其余情况都优先使用异步交互]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Interview</tag>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[详解Java中的Set和List]]></title>
    <url>%2F2018%2F02%2F28%2Fjava%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%844%EF%BC%88Set%E5%92%8CList%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、Set1.Set 里的元素是不能重复的，那么用什么方法来区分重复与否呢？是用 == 还是 equals()？ 它们有何区别? 如果hash码值不相同，说明是一个新元素，存；如果没有元素和传入对象（也就是add的元素）的hash值相等，那么就认为这个元素在table中不存在，将其添加进table； 如果hash码值相同，且equles判断相等，说明元素已经存在，不存；如果hash码值相同，且equles判断不相等，说明元素不存在，存； java中的数据类型，可分为两类：1.基本数据类型也称原始数据类型。byte,short,char,int,long,float,double,boolean,他们之间的比较，应用双等号（==），比较的是他们的值。基本数据类型没有equals方法哦。2.复合数据类型(类)当他们用（==）进行比较的时候，比较的是他们在内存中的存放地址，所以，除非是同一个new出来的对象，他们的比较后的结果为true，否则比较后结果为false。 JAVA当中所有的类都是继承于Object这个基类的，在Object中的基类中定义了一个equals的方法，这个方法的初始行为是比较对象的内存地址，但在一些类库当中这个方法被覆盖掉了，如String,Integer,Date在这些类当中equals有其自身的实现，而不再是比较类在堆内存中的存放地址了。 对于复合数据类型之间进行equals比较，在没有覆写equals方法的情况下，他们之间的比较还是基于他们在内存中的存放位置的地址值的，因为Object的equals方法也是用双等号（==）进行比较的，所以比较后的结果跟双等号（==）的结果相同。 2.TreeMap：TreeMap 是采用什么树实现的？TreeMap、HashMap、LindedHashMap的区别。TreeMap 是一个有序的key-value集合，它是通过红黑树实现的。 TreeMap 继承于AbstractMap，所以它是一个Map，即一个key-value集合。TreeMap 实现了NavigableMap接口，意味着它支持一系列的导航方法。比如返回有序的key集合。TreeMap 实现了Cloneable接口，意味着它能被克隆。 TreeMap 实现了java.io.Serializable接口，意味着它支持序列化。TreeMap基于红黑树（Red-Black tree）实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。 TreeMap的基本操作 containsKey、get、put 和 remove 的时间复杂度是 log(n) 。 另外，TreeMap是非同步的。 它的iterator 方法返回的迭代器是fail-fastl的。 3.TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？TreeSet要求存放的对象所属的类必须实现Comparable接口，该接口提供了比较元素的compareTo()方法，当插入元素时会回调该方法比较元素的大小。TreeMap要求存放的键值对映射的键必须实现Comparable接口从而根据键对元素进行排序。Collections工具类的sort方法有两种重载的形式，第一种要求传入的待排序容器中存放的对象必须实现Comparable接口以实现元素的比较；第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator接口的子类型（需要重写compare方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java中对函数式编程的支持）。 3.TreeSet：一个已经构建好的 TreeSet，怎么完成倒排序。1、自然顺序即类要实现Comparable接口，并重写compareTo()方法，TreeSet对象调用add()方法时，会将存入的对象提升为Comparable类型，然后调用对象中的compareTo()方法进行比较，根据比较的返回值进行存储。因为TreeSet底层是二叉树，当compareTo方法返回0时，不存储；当compareTo方法返回正数时，存入二叉树的右子树；当compareTo方法返回负数时，存入二叉树的左子树。如果一个类没有实现Comparable接口就将该类对象存入TreeSet集合，会发生类型转换异常。2、比较器顺序Comparator创建TreeSet对象的时候可以指定一个比较器，即传入一个Comparator对象，那么TreeSet会优先按照Comparator中的compare()方法排序，compare方法中有两个参数，第一个是调用该方法的对象，第二个值集合中已经存入的对象。 4.EnumSet 是什么5.HashSet和TreeSet有什么区别? 底层存储的数据结构不同HashSet底层用的是HashMap哈希表结构存储，而TreeSet底层用的是TreeMap树结构存储 存储时保证数据唯一性依据不同HashSet是通过复写hashCode()方法和equals()方法来保证的，而HashSet通过Compareable接口的compareTo()方法来保证的 有序性不一样HashSet无序，TreeSet有序6.HashSet 内部是如何工作的HashSet:底层数据结构是哈希表，本质就是对哈希值的存储，通过判断元素的hashCode方法和equals方法来保证元素的唯一性，当hashCode值不相同，就直接存储了，不用在判断equals了，当hashCode值相同时，会在判断一次euqals方法的返回值是否为true，如果为true则视为用一个元素，不用存储，如果为false，这些相同哈希值不同内容的元素都存放一个bucket桶里（当哈希表中有一个桶结构，每一个桶都有一个哈希值）TreeSet:底层的数据结构是二叉树，可以对Set集合中的元素进行排序,这种结构，可以提高排序性能, 根据比较方法的返回值确定的,只要返回的是0.就代表元素重复 7.WeakHashMap 是怎么工作的？二、 List1.List, Set, Map三个接口，存取元素时各有什么特点？List与Set都是单列元素的集合，它们有一个功共同的父接口Collection。Set里面不允许有重复的元素，存元素：add方法有一个boolean的返回值，当集合中没有某个元素，此时add方法可成功加入该元素时，则返回true；当集合含有与某个元素equals相等的元素时，此时add方法无法加入该元素，返回结果为false。取元素：没法说取第几个，只能以Iterator接口取得所有的元素，再逐一遍历各个元素。 List表示有先后顺序的集合，存元素：多次调用add(Object)方法时，每次加入的对象按先来后到的顺序排序，也可以插队，即调用add(int index,Object)方法，就可以指定当前对象在集合中的存放位置。取元素：方法1：Iterator接口取得所有，逐一遍历各个元素方法2：调用get(index i)来明确说明取第几个。使用此接口能够精确的控制每个元素插入的位置。用户能够使用索引（元素在List中的位置，类似于数组下标）来访问List中的元素，这类似于Java的数组。 Map是双列的集合，存放用put方法:put(obj key,obj value)，每次存储时，要存储一对key/value，不能存储重复的key，这个重复的规则也是按equals比较相等。取元素：用get(Object key)方法根据key获得相应的value。也可以获得所有的key的集合，还可以获得所有的value的集合，还可以获得key和value组合成的Map.Entry对象的集合。 List以特定次序来持有元素，可有重复元素。Set无法拥有重复元素,内部排序。Map 保存key-value值，value可多值。 2.List, Set, Map 是否继承自 Collection 接口List和Set是的，而Map不是。 3.遍历一个 List 有哪些不同的方式12345678910111213141516171819Iterator it1 = list.iterator();while(it1.hasNext())&#123; System.out.println(it1.next());&#125;//方法2for(Iterator it2 = list.iterator();it2.hasNext();)&#123; System.out.println(it2.next());&#125;//方法3for(String tmp:list)&#123; System.out.println(tmp);&#125;//方法4for(int i = 0;i &lt; list.size(); i ++)&#123; System.out.println(list.get(i));&#125; 三、LinkedList1.LinkedList 是单向链表还是双向链表Linkedlist，双向链表，优点，增加删除，用时间很短，但是因为没有索引，对索引的操作，比较麻烦，只能循环遍历，但是每次循环的时候，都会先判断一下，这个索引位于链表的前部分还是后部分，每次都会遍历链表的一半 ，而不是全部遍历。双向链表，都有一个previous和next， 链表最开始的部分都有一个fiest和last指向第一个元素，和最后一个元素。增加和删除的时候，只需要更改一个previous和next，就可以实现增加和删除，所以说，LinkedList对于数据的删除和增加相当的方便。 2.LinkedList 与 ArrayList 有什么区别? 因为Array是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的。Array获取数据的时间复杂度是O(1),但是要删除数据却是开销很大的，因为这需要重排数组中的所有数据。 相对于ArrayList，LinkedList插入是更快的。因为LinkedList不像ArrayList一样，不需要改变数组的大小，也不需要在数组装满的时候要将所有的数据重新装入一个新的数组，这是ArrayList最坏的一种情况，时间复杂度是O(n)，而LinkedList中插入或删除的时间复杂度仅为O(1)。ArrayList在插入数据时还需要更新索引（除了插入数组的尾部）。 类似于插入数据，删除数据时，LinkedList也优于ArrayList。 LinkedList需要更多的内存，因为ArrayList的每个索引的位置是实际的数据，而LinkedList中的每个节点中存储的是实际的数据和前后节点的位置。 3.描述下 Java 中集合（Collections），接口（Interfaces），实现（Implementations）的概念。4.插入数据时，ArrayList, LinkedList, Vector谁速度较快？ArrayList和Vector都是数组实现，但不同的是，Vector是线程安全，加了同步，所以原则上ArrayList比Vector比快；LinkekList是链表实现，增删快，查找慢，所以你要是插入数据时，显然LinkedList是最快的，其次是ArrayList，再者Vector属于遗留容器（Java早期的版本中提供的容器，除此之外，Hashtable、Dictionary、BitSet、Stack、Properties都是遗留容器），已经不推荐使用，但是由于ArrayList和LinkedListed都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类Collections中的synchronizedList方法将其转换成线程安全的容器后再使用（这是对装潢模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现）。 四、ArrayList1.ArrayList 和 HashMap 的默认大小是多数?这里要讨论这些常用的默认初始容量和扩容的原因是：当底层实现涉及到扩容时，容器或重新分配一段更大的连续内存（如果是离散分配则不需要重新分配，离散分配都是插入新元素时动态分配内存），要将容器原来的数据全部复制到新的内存上，这无疑使效率大大降低。加载因子的系数小于等于1，意指 即当元素个数 超过 容量长度*加载因子的系数 时，进行扩容。另外，扩容也是有默认的倍数的，不同的容器扩容情况不同。 ArrayList、Vector默认初始容量为10。Vector：线程安全，但速度慢。底层数据结构是数组结构，加载因子为1：即当 元素个数 超过 容量长度 时，进行扩容。扩容增量：原容量的 1倍。如 Vector的容量为10，一次扩容后是容量为20。ArrayList：线程不安全，查询速度快。底层数据结构是数组结构，扩容增量：原容量的 0.5倍+1，如 ArrayList的容量为10，一次扩容后是容量为16。 Set(集) 元素无序的、不可重复。HashSet：线程不安全，存取速度快。底层实现是一个HashMap（保存数据），实现Set接口默认初始容量为16（为何是16，见下方对HashMap的描述）加载因子为0.75：即当 元素个数 超过 容量长度的0.75倍 时，进行扩容扩容增量：原容量的1倍如 HashSet的容量为16，一次扩容后是容量为32。 Map是一个双列集合HashMap：默认初始容量为16（为何是16：16是2^4，可以提高查询效率，另外，32=16&lt;&lt;1 –&gt;至于详细的原因可另行分析，或分析源代码）加载因子为0.75：即当 元素个数 超过 容量长度的0.75倍 时，进行扩容扩容增量：原容量的 1倍如 HashSet的容量为16，一次扩容后是容量为32。 2.ArrayList 和 Set 的区别？ Set 集合是无序不可以重复的的、List集合是有序可以重复的。 ArrayList是数组存储的方式，HashSet存储会先进行HashCode值得比较(hashcode和equals方法)，若相同就不会再存储。 补充一下：Hashset就是采用哈希算法存取对象的集合，对象用完之后没有回收就是内存泄漏。一个对象一旦hashCode生成之后，再对属性值修改后其Hashcode值就会发生改变，再通过hashSet删除就删除不掉了。 以上的问题还可以继续有如下变形，理解了就能融会贯通：ArrayList, LinkedList, Vector的区别ArrayList是如何实现的，ArrayList 和 LinkedList 的区别ArrayList如何实现扩容 6.Array 和 ArrayList 有何区别？什么时候更适合用Array？ArrayList可以算是Array的加强版，（对array有所取舍的加强）。存储内容比较： •Array数组可以包含基本类型和对象类型，•ArrayList却只能包含对象类型。但是需要注意的是：Array数组在存放的时候一定是同种类型的元素。ArrayList就不一定了，因为ArrayList可以存储Object。 空间大小比较：• 它的空间大小是固定的，空间不够时也不能再次申请，所以需要事前确定合适的空间大小。• ArrayList的空间是动态增长的，如果空间不够，它会创建一个空间比原空间大一倍的新数组，然后将所有元素复制到新数组中，接着抛弃旧数组。而且，每次添加新的元素的时候都会检查内部数组的空间是否足够。（比较麻烦的地方）。 方法上的比较： ArrayList作为Array的增强版，当然是在方法上比Array更多样化，比如添加全部addAll()、删除全部removeAll()、返回迭代器iterator()等。 适用场景：如果想要保存一些在整个程序运行期间都会存在而且不变的数据，我们可以将它们放进一个全局数组里，但是如果我们单纯只是想要以数组的形式保存数据，而不对数据进行增加等操作，只是方便我们进行查找的话，那么，我们就选择ArrayList。而且还有一个地方是必须知道的，就是如果我们需要对元素进行频繁的移动或删除，或者是处理的是超大量的数据，那么，使用ArrayList就真的不是一个好的选择，因为它的效率很低，使用数组进行这样的动作就很麻烦，那么，我们可以考虑选择LinkedList。]]></content>
      <categories>
        <category>Java Basic</category>
      </categories>
      <tags>
        <tag>Interview</tag>
        <tag>java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java里必须要会的Hash]]></title>
    <url>%2F2018%2F02%2F28%2Fjava%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842%EF%BC%88Hash%E7%AF%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1.Hashcode 的作用对于包含容器类型的程序设计语言来说，基本上都会涉及到 hashCode。在Java中也一样，hashCode方法的主要作用是为了配合基于散列的集合一起正常运行，这样的散列集合包括HashSet、HashMap以及HashTable。为什么这么说呢？考虑一种情况，当向集合中插入对象时，如何判别在集合中是否已经存在该对象了？（注意：集合中不允许重复的元素存在）也许大多数人都会想到调用equals方法来逐个进行比较，这个方法确实可行。但是如果集合中已经存在一万条数据或者更多的数据，如果采用equals方法去逐一比较，效率必然是一个问题。此时hashCode方法的作用就体现出来了，当集合要添加新的对象时，先调用这个对象的hashCode方法，得到对应的hashcode值，实际上在HashMap的具体实现中会用一个table保存已经存进去的对象的hashcode值，如果table中没有该hashcode值，它就可以直接存进去，不用再进行任何比较了；如果存在该hashcode值， 就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址，所以这里存在一个冲突解决的问题，这样一来实际调用equals方法的次数就大大降低了，说通俗一点：Java中的hashCode方法就是根据一定的规则将与对象相关的信息（比如对象的存储地址，对象的字段等）映射成一个数值，这个数值称作为散列值。1234567891011121314151617181920//java.util.HashMap的中put方法的具体实现：public V put(K key, V value) &#123; if (key == null) return putForNullKey(value); int hash = hash(key.hashCode()); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(hash, key, value, i); return null;&#125; put方法是用来向HashMap中添加新的元素，从put方法的具体实现可知，会先调用hashCode方法得到该元素的hashCode值，然后查看table中是否存在该hashCode值，如果存在则调用equals方法重新确定是否存在该元素，如果存在，则更新value值，否则将新的元素添加到HashMap中。从这里可以看出，hashCode方法的存在是为了减少equals方法的调用次数，从而提高程序效率。 《浅谈Java中的hashcode方法》 2.简述一致性 Hash 算法一致性哈希修正了CARP使用的简单哈希算法带来的问题，在分布式系统中也得到了广泛应用。一致性hash算法（DHT）通过减少影响范围的方式解决了增减服务器导致的数据散列问题，从而解决了分布式环境下负载均衡问题，如果存在热点数据，那么通过增添节点的方式，对热点区间进行划分，将压力分配至其他服务器。重新达到负载均衡的状态。 《一致性哈希算法1》《一致性哈希算法2》 3.有没有可能两个不相等的对象有相同的 hashcode？当两个对象hashcode 相同怎么办？如何获取值对象？对于两个对象： 如果调用equals方法得到的结果为true，则两个对象的hashcode值必定相等； 如果equals方法得到的结果为false，则两个对象的hashcode值不一定不同； 如果两个对象的hashcode值不等，则equals方法得到的结果必定为false； 如果两个对象的hashcode值相等，则equals方法得到的结果未知。 总之一句话：等价对象产生相同整数的哈希码，不同对象不一定要不同的哈希码。后面两个命题其实就是这句话的逆否命题。 所以，针对上面问题提到的，两个不相等的对象其实就是问的equals为false，那么hashcode不一定是不同，也就是有可能会相同了。为什呢会这样呢？hashCode是所有java对象的固有方法，如果不重载的话，返回的实际上是该对象在jvm的堆上的内存地址，而不同对象的内存地址肯定不同，所以这个hashCode也就肯定不同了。如果重载了的话，由于采用的算法的问题，有可能导致两个不同对象的hashCode相同。后面的问题其实会比较多的出现在Map的面试考察中，当我们调用Map的get()方法，HashMap会使用键对象的hashcode找到bucket位置，然后获取值对象。面试官提醒他如果有两个值对象储存在同一个bucket，他给出答案：将会遍历链表直到找到值对象。面试官会问因为你并没有值对象去比较，你是如何确定确定找到值对象的？除非面试者直HashMap在链表中存储的是键值对，否则他们不可能回答出这一题。其中一些记得这个重要知识点的面试者会说，找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。完美的答案！ 4.为什么在重写 equals 方法的时候需要重写 hashCode 方法？equals与hashCode 的异同点在哪里?这里头牵扯到另外隐含的问题，一并拿出来解决： 1、首先我们为什么需要重写hashCode()方法和equals()方法2、为什么在重写 equals 方法的时候需要重写 hashCode 方法？3、如何重写这两个方法? 回答第一个问题：Java中的超类Object类中定义的equals()方法是用来比较两个引用所指向的对象的内存地址是否一致，Object类中equals()方法的源码123public boolean equals(Object obj) &#123; return (this == obj);&#125; Object类中的hashCode()方法，用native关键字修饰，说明这个方法是个原生函数，也就说这个方法的实现不是用java语言实现的，是使用c/c++实现的，并且被编译成了DLL，由java去调用，jdk源码中不包含。对于不同的平台它们是不同的，java在不同的操作系统中调用不同的native方法实现对操作系统的访问，因为java语言不能直接访问操作系统底层，因为它没有指针。Java的API文档对hashCode()方法做了详细的说明，这也是我们重写hashCode()方法时的原则【Object类】1public native int hashCode(); 我们在定义类时，我们经常会希望两个不同对象的某些属性值相同时就认为他们相同，所以我们要重写equals()方法，但同时也要改写hashCode()方法，所以java中的很多类都重写了这两个方法,例如String类，包装类。第二个问题：为什么在重写 equals 方法的时候需要重写 hashCode 方法？Java 对于hashCode方法的规约： 在java应用程序运行时，无论何时多次调用同一个对象时的hsahCode()方法，这个对象的hashCode()方法的返回值必须是同一个int值 如果两个对象equals()返回值为true,则他们的hashCode()也必须返回相同的int值 如果两个对象根据equals()比较是不等的，则hashCode()方法不一定得返回不同的整数。 根据规约，为了保证同一个对象，equals相同的情况下hashcode值必定相同，如果重写了equals而未重写hashcode方法，可能就会出现两个对象equals相同的（因为equal都是根据对象的特征进行重写的），但hashcode确实不相同的。如果不这样做程序也可以执行，只不过会隐藏bug。比如重写了equals方法，属性相同就认为相同，但不重写hashcode，那么我们再new一个新的对象，当原对象equals（新对象）等于true时，两者的hashcode却是不一样的，由此将产生了理解的不一致，如在存储散列集合时（如Set类），将会存储了两个值一样的对象，导致混淆，因此就也需要重写hashcode()。【一句话，容易在要求散列存储的时候，把相同对象给放到一个集合】有这个要求的症结在于，要考虑到类似HashMap、HashTable、HashSet的这种散列的数据类型的运用。 5.a.hashCode() 有什么用？与 a.equals(b) 有什么关系？ 如果调用equals方法得到的结果为true，则两个对象的hashcode值必定相等； 如果equals方法得到的结果为false，则两个对象的hashcode值不一定不同； 如果两个对象的hashcode值不等，则equals方法得到的结果必定为false； 如果两个对象的hashcode值相等，则equals方法得到的结果未知。 总之一句话：等价对象产生相同整数的哈希码，不同对象不一定要不同的哈希码。后面两个命题其实就是这句话的逆否命题。 6.hashCode() 和 equals() 方法的重要性体现在什么地方？散列存储集合如HashMap的很多函数要基于equal()函数和hashCode()函数。hashCode()用来定位要存放的位置，equal()用来判断是否相等。那么，相等的概念是什么？Object版本的equal只是简单地判断是不是同一个实例。但是有的时候，我们想要的的是逻辑上的相等。比如有一个学生类student，有一个属性studentID，只要studentID相等，不是同一个实例我们也认为是同一学生。当我们认为判定equals的相等应该是逻辑上的相等而不是只是判断是不是内存中的同一个东西的时候，就需要重写equal()。而涉及到HashMap的时候，重写了equals()，就需要重写hashCode() 7.Object类hashcode,equals 设计原则？ sun为什么这么设计？ 在程序执行期间，只要equals方法的比较操作用到的信息没有被修改，那么对这同一个对象调用多次，hashCode方法必须始终如一地返回同一个整数。 如果两个对象根据equals方法比较是相等的，那么调用两个对象的hashCode方法必须返回相同的整数结果。 如果两个对象根据equals方法比较是不等的，则hashCode方法不一定得返回不同的整数。 以上是摘自Effective Java的原话，下面进行具体解读： 1.同一个对象（没有发生过修改）无论何时调用hashCode()得到的返回值必须一样。如果一个key对象在put的时候调用hashCode()决定了存放的位置，而在get的时候调用hashCode()得到了不一样的返回值，这个值映射到了一个和原来不一样的地方，那么肯定就找不到原来那个键值对了。 2.hashCode()的返回值相等的对象不一定相等，通过hashCode()和equals()必须能唯一确定一个对象不相等的对象的hashCode()的结果可以相等。hashCode()在注意关注碰撞问题的时候，也要关注生成速度问题，完美hash不现实。 3.一旦重写了equals()函数（重写equals的时候还要注意要满足自反性、对称性、传递性、一致性），就必须重写hashCode()函数。而且hashCode()的生成哈希值的依据应该是equals()中用来比较是否相等的字段 。如果两个由equals()规定相等的对象生成的hashCode不等，对于hashMap来说，他们很可能分别映射到不同位置，没有调用equals()比较是否相等的机会，两个实际上相等的对象可能被插入不同位置，出现错误。其他一些基于哈希方法的集合类可能也会有这个问题。【牛客网面试题】 8.Object：Object有哪些公用方法？Object类的概述。Object是所有类的父类，任何类都默认继承Object。clone：保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常equals：在Object中与==是一样的，子类一般需要重写该方法hashCode：该方法用于哈希查找，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到getClass：final方法，获得运行时类型wait：使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。 调用该方法后当前线程进入睡眠状态，直到以下事件发生： 其他线程调用了该对象的notify方法 其他线程调用了该对象的notifyAll方法 其他线程调用了interrupt中断该线程 时间间隔到了，此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常 notify：唤醒在该对象上等待的某个线程notifyAll：唤醒在该对象上等待的所有线程toString：转换成字符串，一般子类都有重写，否则打印句柄 如何在父类中为子类自动完成所有的 hashcode 和 equals 实现？这么做有何优劣。可以在 hashcode() 中使用随机数字吗？]]></content>
      <categories>
        <category>Java Basic</category>
      </categories>
      <tags>
        <tag>Interview</tag>
        <tag>java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础之数据结构（基础篇）]]></title>
    <url>%2F2018%2F02%2F28%2Fjava%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841%EF%BC%88%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、基础类型(Primitives)1.基础类型(Primitives)与封装类型(Wrappers)的区别在哪里？1 传递方式不同封装类是引用类型。基本类型（原始数据类型）在传递参数时都是按值传递，而封装类型是按引用传递的(其实“引用也是按值传递的”，传递的是对象的地址)。由于包装类型都是final修饰的不可变量，因此没有提供改变它值的方法，增加了对“按引用传递”的理解难度。int是基本类型，直接存放数值；Integer是类，产生对象时用一个引用指向这个对象。2 封装类可以有方法和属性封装类可以有方法和属性，利用这些方法和属性来处理数据，如Integer.parseInt(Strings)。基本数据类型都是final修饰的，不能继承扩展新的类、新的方法。3 默认值不同基本类型跟封装类型的默认值是不一样的。如int i,i的预设为0；Integer j，j的预设为null,因为封装类产生的是对象，对象默认值为null。4 存储位置基本类型在内存中是存储在栈中，引用类型的引用（值的地址）存储在栈中，而实际的对象（值）是存在堆中。基本数据类型的好处就是速度快（不涉及到对象的构造和回收），封装类的目的主要是更好的处理数据之间的转换。JDK5.0开始可以自动封包了，基本数据类型可以自动封装成封装类。 《 基础类型(Primitives)与封装类型(Wrappers)的区别》 2.简述九种基本数据类型的大小，以及他们的封装类。 3.int和 Integer 哪个会占用更多的内存？int和 Integer 有什么区别？parseInt()函数在什么时候使用到？当然是Integer会占用更多的内存。以下为int和Integer的区别：1、Integer是int的包装类，int则是java的一种基本数据类型2、Integer变量必须实例化后才能使用，而int变量不需要3、Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值4、Integer的默认值是null，int的默认值是0延伸关于Integer和int的比较 ： 由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。 123Integer i = new Integer(100);Integer j = new Integer(100);System.out.print(i == j); //false Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较） 123Integer i = new Integer(100);int j = 100；System.out.print(i == j); //true 非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。（因为非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同） 123Integer i = new Integer(100);Integer j = 100;System.out.print(i == j); //false 对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false 123456Integer i = 100;Integer j = 100;System.out.print(i == j); //trueInteger i = 128;Integer j = 128;System.out.print(i == j); //false 对于第4条的原因：java在编译Integer i = 100 ;时，会翻译成为Integer i = Integer.valueOf(100)；，而java API中对Integer类型的valueOf的定义如下：1234567public static Integer valueOf(int i)&#123; assert IntegerCache.high &gt;= 127; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)&#123; return IntegerCache.cache[i + (-IntegerCache.low)]; &#125; return new Integer(i);&#125; java对于-128到127之间的数，会进行缓存，Integer i = 127时，会将127进行缓存，下次再写Integer j = 127时，就会直接从缓存中取，就不会new了。 《int和Integer的区别》 parseInt()parseInt()将把该字符之前的字符串转换成数字。parseInt()方法还有基模式，可以把二进制、八进制、十六进制或其他任何进制的字符串转换成整数。基是由parseInt()方法的第二个参数指定的，所以要解析十六进制的值，当然，对二进制、八进制，甚至十进制（默认模式），都可以这样调用parseInt()方法。如果十进制数包含前导0，那么最好采用基数10，这样才不会意外地得到八进制的值。12static int parseInt(String s)static int parseInt(String s, int radix) 4.如何去小数四舍五入保留小数点后两位？12//使用银行家算法BigDecimal i = d.multiply(r).setScale(2,RoundingMode.HALF_EVEN); 推荐使用BigDecimal ，并且采用setScale方法来设置精确度，同时使用RoundingMode.HALF_UP表示使用最近数字舍入法则来近似计算。在这里我们可以看出BigDecimal和四舍五入是绝妙的搭配。《java提高篇(三)—–java的四舍五入》 5.char 型变量中能不能存贮一个中文汉字，为什么？char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字，所以char型变量中当然可以存储汉字啦。不过，如果某个特殊的汉字没有被包含在unicode编码字符集中，那么，这个char型变量中就不能存储这个特殊汉字。补充说明：unicode编码占用两个字节，所以，char类型的变量也是占用两个字节。 二、类型转换1.怎样将 bytes 转换为 long 类型12345678910public static long bytes2long(byte[] b) &#123; long temp = 0; long res = 0; for (int i=0;i&lt;8;i++) &#123; res &lt;&lt;= 8; temp = b[i] &amp; 0xff; res |= temp; &#125; return res;&#125; 2.怎么将 byte 转换为 String**123456//string 转成 bytestring s = "Hello!!";byte[] b = new byte[1024*1024];b = System.Text.Encoding.ASCII.GetBytes(s);//当string含有中文字符时用 System.Text.Encoding.UTF8.GetBytes(s);sock.Send(b); 12345//byte 转成 stringbyte[] b1 = new byte[1024*1024*2];sock.Receive(b1);string s1 = System.Text.Encoding.ASCII.GetString(b1);// System.Text.Encoding.UTF8.GetString(b1); 注意： 在把byte数组转换成string的时候，由于byte数组有2M的字节，所以转换后得到的字符串s1也会填充到2M的字符（用\0来填充）所以，为了避免这个问题，可以使用Receive返回的字节数来确定接收到byte的长度123int length = sock.Receive(b1);string s1 = System.Text.Encoding.ASCII.GetString(b1, 0, length);//这样，s1就为byte实际的值 3.如何将数值型字符转换为数字string和int之间的转换 string转换成int : Integer.valueOf(&quot;12&quot;) int转换成string : String.valueOf(12) char转int之间的转换 首先将char转换成stringString str=String.valueOf(&#39;2&#39;)Integer.valueof(str) 或者Integer.PaseInt(str)Integer.valueof返回的是Integer对象，Integer.paseInt返回的是int 4.我们能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象Byte转int1234567public static int bytes2int(byte[] bytes) &#123; int num = bytes[0] &amp; 0xFF; num |= ((bytes[1] &lt;&lt; 8) &amp; 0xFF00); num |= ((bytes[2] &lt;&lt; 16) &amp; 0xFF0000); num |= ((bytes[3] &lt;&lt; 24) &amp; 0xFF000000); return num;&#125; int转 byte12345678public static byte[] int2bytes(int i) &#123; byte[] b = new byte[4]; b[0] = (byte) (0xff&amp;i); b[1] = (byte) ((0xff00&amp;i) &gt;&gt; 8); b[2] = (byte) ((0xff0000&amp;i) &gt;&gt; 16); b[3] = (byte) ((0xff000000&amp;i) &gt;&gt; 24); return b;&#125; 5.能在不进行强制转换的情况下将一个 double 值赋值给 long 类型的变量吗?123456789public static void main(String[] args) &#123; double d = 88.88; long l = Math.round(d); System.out.println(l); long ll = 100L; double dd = (double) ll; System.out.println(dd);&#125; 6.类型向下转换是什么?由低层次类型转换为高层次类型称为向上类型转换。向上类型转换是自动进行的，比如把int型变量赋给为long型变量，把long型变量赋给double型变量，转换都是自动进行的。由派生类转换为基类也是向上提升，也是自动进行的，但转换后，基类的引用符不能应用派生类对象特有的函数。123Human jean = new Human();Vervebrata someone = jean;some.Work(); 运行上面语句会出错，虽然someone指向了一个Human类的对象，但是它不能调用Work()函数，因为someone的类型为Vertebrata，而基类Vertebrata中没有申明Work()函数。要想通过基类引用符someone调用派生类特有的函数，必须将someone的类型强制转换为派生类。这种由基类向派生类转换的过程称为向下类型转换。 三、 数组1.如何权衡是使用无序的数组还是有序的数组在数据偏向查找操作的时候用有序数组快一些，在数据偏向插入的时候，无序数组好一些。删除操作效率一样。 2.怎么判断数组是 null 还是为空（无论使用哪种类型的数组，数组标识符其实只是一个引用，指向在堆中创建的一个真实对象 Int[] A =new int[10];new 一下就是实例化了，开辟了内存空间，基本数据类型的元素会被赋初始值，数组建立后长度不能改变，但是还是可以重新赋值）有如下两个变量定义： 1 int[] zero = new int[0]; 2 int[] nil = null;这两种定义有什么区别呢？zero是一个长度为0的数组，我们称之为“空数组”，空数组也是一个对象，只是包含元素个数为0。nil是一个数组类型的空引用。 3.怎么打印数组？ 怎样打印数组中的重复元素4.Array 和 ArrayList有什么区别？什么时候应该使用Array而不是ArrayList?1）精辟阐述：可以将 ArrayList想象成一种“会自动扩增容量的Array”。2）Array（[]）：最高效；但是其容量固定且无法动态改变； ArrayList： 容量可动态增长；但牺牲效率；3）建议：基于效率和类型检验，应尽可能使用Array，无法确定数组大小时才使用ArrayList！不过当你试着解决更一般化的问题时，Array的功能就可能过于受限。4）Java中一切皆对象，Array也是对象。不论你所使用得Array型别为何，Array名称本身实际上是个reference，指向heap之内得某个实际对象。这个对象可经由“Array初始化语法”被自动产生，也可以以new表达式手动产生。5）Array可做为函数返回值，因为它本身是对象的reference；6）对象数组与基本类型数组在运用上几乎一模一样，唯一差别在于，前者持有得是reference，后者直接持有基本型别之值；例如：12string [] staff=new string[100];int [] num=new int[10]; 7）容器所持有的其实是一个reference指向Object，进而才能存储任意型别。当然这不包括基本型别，因为基本型别并不继承自任何classes。8）面对Array，我们可以直接持有基本型别数值的Array（例如：int [] num;),也可以持有reference（指向对象）的Array；但是容器类仅能持有reference（指向对象），若要将基本型别置于容器内，需要使用wrapper类。但是wrapper类使用起来可能不很容易上手，此外，primitives Array的效率比起“容纳基本型别之外覆类（的reference）”的容器好太多了。当然，如果你的操作对象是基本型别，而且需要在空间不足时自动扩增容量，Array便不适合，此时就得使用外覆类的容器了。9）某些情况下，容器类即使没有转型至原来的型别，仍然可以运作无误。有一种情况尤其特别：编译器对String class提供了一些额外的支持，使它可以平滑运作。10）对数组的一些基本操作，像排序、搜索与比较等是很常见的。因此在Java中提供了Arrays类协助这几个操作：sort(),binarySearch(),equals(),fill(),asList().不过Arrays类没有提供删除方法，而ArrayList中有remove()方法，不知道是否是不需要在Array中做删除等操作的原因（因为此时应该使用链表）。11）ArrayList的使用也很简单：产生ArrayList，利用add()将对象置入，利用get(i）配合索引值将它们取出。这一切就和Array的使用方式完全相同，只不过少了[]而已。 换一种简单说法：1）效率：数组扩容是对ArrayList效率影响比较大的一个因素。每当执行Add、AddRange、Insert、InsertRange等添加元素的方法，都会检查内部数组的容量是否不够了，如果是，它就会以当前容量的两倍来重新构建一个数组，将旧元素Copy到新数组中，然后丢弃旧数组，在这个临界点的扩容操作，应该来说是比较影响效率的。ArrayList是Array的复杂版本ArrayList内部封装了一个Object类型的数组，从一般的意义来说，它和数组没有本质的差别，甚至于ArrayList的许多方法，如Index、IndexOf、Contains、Sort等都是在内部数组的基础上直接调用Array的对应方法。2）类型识别：ArrayList存入对象时，抛弃类型信息，所有对象屏蔽为Object，编译时不检查类型，但是运行时会报错。但是现在有jdk1.5后引入泛型来进行编译检查类型，如错存入了不同类型会直接报错。ArrayList与数组的区别主要就是由于动态增容的效率问题了3）ArrayList可以存任何Object，如String等。 5.数组和链表数据结构描述，各自的时间复杂度数组是将元素在内存中连续存放，由于每个元素占用内存相同，可以通过下标迅速访问数组中任何元素。但是如果要在数组中增加一个元素，需要移动大量元素，在内存中空出一个元素的空间，然后将要增加的元素放在其中。同样的道理，如果想删除一个元素，同样需要移动大量元素去填掉被移动的元素。如果应用需要快速访问数据，很少插入和删除元素，就应该用数组。链表中的元素在内存中不是顺序存储的，而是通过存在元素中的指针联系到一起，每个结点包括两个部分：一个是存储 数据元素的数据域，另一个是存储下一个结点地址的 指针。 如果要访问链表中一个元素，需要从第一个元素开始，一直找到需要的元素位置。但是增加和删除一个元素对于链表数据结构就非常简单了，只要修改元素中的指针就可以了。如果应用需要经常插入和删除元素你就需要用链表。 内存存储区别数组从栈中分配空间, 对于程序员方便快速,但自由度小。链表从堆中分配空间, 自由度大但申请管理比较麻烦. 逻辑结构区别数组必须事先定义固定的长度（元素个数），不能适应数据动态地增减的情况。当数据增加时，可能超出原先定义的元素个数；当数据减少时，造成内存浪费。 链表动态地进行存储分配，可以适应数据动态地增减的情况，且可以方便地插入、删除数据项。（数组中插入、删除数据项时，需要移动其它数据项） 总结1、存取方式上，数组可以顺序存取或者随机存取，而链表只能顺序存取； 2、存储位置上，数组逻辑上相邻的元素在物理存储位置上也相邻，而链表不一定； 3、存储空间上，链表由于带有指针域，存储密度不如数组大； 4、按序号查找时，数组可以随机访问，时间复杂度为O(1)，而链表不支持随机访问，平均需要O(n)； 5、按值查找时，若数组无序，数组和链表时间复杂度均为O(1)，但是当数组有序时，可以采用折半查找将时间复杂度降为O(logn)； 6、插入和删除时，数组平均需要移动n/2个元素，而链表只需修改指针即可； 7、空间分配方面：数组在静态存储分配情形下，存储元素数量受限制，动态存储分配情形下，虽然存储空间可以扩充，但需要移动大量元素，导致操作效率降低，而且如果内存中没有更大块连续存储空间将导致分配失败；链表存储的节点空间只在需要的时候申请分配，只要内存中有空间就可以分配，操作比较灵活高效；数组有没有length()这个方法? String有没有length()这个方法 四、队列1.队列和栈是什么，列出它们的区别队列（Queue）：是限定只能在表的一端进行插入和在另一端进行删除操作的线性表；栈（Stack）：是限定只能在表的一端进行插入和删除操作的线性表。区别如下： 规则不同 1. 队列：先进先出（First In First Out）FIFO 2. 栈：先进后出（First In Last Out ）FILO 对插入和删除操作的限定不同 1. 队列：只能在表的一端进行插入，并在表的另一端进行删除； 2. 栈：只能在表的一端插入和删除。 遍历数据速度不同 1. 队列：基于地址指针进行遍历，而且可以从头部或者尾部进行遍历，但不能同时遍历，无需开辟空间，因为在遍历的过程中不影响数据结构，所以遍历速度要快； 2. 栈：只能从顶部取数据，也就是说最先进入栈底的，需要遍历整个栈才能取出来，而且在遍历数据的同时需要为数据开辟临时空间，保持数据在遍历前的一致性。 2.BlockingQueue是什么 阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。 《聊聊并发（7）Java中的阻塞队列》 3.简述 ConcurrentLinkedQueue LinkedBlockingQueue 的用处和不同之处。 阻塞队列：线程安全按 FIFO（先进先出）排序元素。队列的头部是在队列中时间最长的元素。队列的尾部是在队列中时间最短的元素。新元素插入到队列的尾部，并且队列检索操作会获得位于队列头部的元素。链接队列的吞吐量通常要高于基于数组的队列，但是在大多数并发应用程序中，其可预知的性能要低。注意：1、必须要使用take()方法在获取的时候达成阻塞结果2、使用poll()方法将产生非阻塞效果 非阻塞队列基于链接节点的、无界的、线程安全。此队列按照 FIFO（先进先出）原则对元素进行排序。队列的头部 是队列中时间最长的元素。队列的尾部 是队列中时间最短的元素。新的元素插入到队列的尾部，队列检索操作从队列头部获得元素。当许多线程共享访问一个公共 collection 时，ConcurrentLinkedQueue是一个恰当的选择。此队列不允许 null 元素。 在并发编程中，一般推荐使用阻塞队列，这样实现可以尽量地避免程序出现意外的错误。阻塞队列使用最经典的场景就是socket客户端数据的读取和解析，读取数据的线程不断将数据放入队列，然后解析线程不断从队列取数据解析。还有其他类似的场景，只要符合生产者-消费者模型的都可以使用阻塞队列。使用非阻塞队列，虽然能即时返回结果（消费结果），但必须自行编码解决返回为空的情况处理（以及消费重试等问题）。另外他们都是线程安全的，不用考虑线程同步问题。 《JAVA阻塞队列以及非阻塞队列的区别》 4.ArrayList、Vector、LinkedList的存储性能和特性ArrayList 和Vector他们底层的实现都是一样的，都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢。 Vector中的方法由于添加了synchronized修饰，因此Vector是线程安全的容器，但性能上较ArrayList差，因此已经是Java中的遗留容器。 LinkedList使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。 Vector属于遗留容器（Java早期的版本中提供的容器，除此之外，Hashtable、Dictionary、BitSet、Stack、Properties都是遗留容器），已经不推荐使用，但是由于ArrayList和LinkedListed都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类Collections中的synchronized List方法将其转换成线程安全的容器后再使用（这是对装潢模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现）。 五、String1.ByteBuffer 与 StringBuffer有什么区别六、Collections1.介绍Java中的Collection FrameWork。集合类框架的基本接口有哪些？总共有两大接口：Collection 和Map ，一个元素集合，一个是键值对集合； 其中List和Set接口继承了Collection接口，一个是有序元素集合，一个是无序元素集合； ArrayList和LinkedList实现了List接口，HashSet实现了Set接口，这几个都比较常用； HashMap和HashTable实现了Map接口，并且HashTable是线程安全的，但是HashMap性能更好； 2.Collections类是什么？Collection 和 Collections的区别？Collection、Map的实现.Collection是单列集合 List元素是有序的、可重复。有序的collection，可以对列表中每个元素的插入位置进行精确地控制。可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。 可存放重复元素，元素存取是有序的。 List接口中常用类Vector：线程安全，但速度慢，已被ArrayList替代。底层数据结构是数组结构；ArrayList：线程不安全，查询速度快。底层数据结构是数组结构；LinkedList：线程不安全。增删速度快。底层数据结构是列表结构； Set(集) 元素无序的、不可重复。取出元素的方法只有迭代器。不可以存放重复元素，元素存取是无序的。 Set接口中常用的类HashSet：线程不安全，存取速度快。它是如何保证元素唯一性的呢？依赖的是元素的hashCode方法和euqals方法。TreeSet：线程不安全，可以对Set集合中的元素进行排序。它的排序是如何进行的呢？通过compareTo或者compare方法中的来保证元素的唯一性。元素是以二叉树的形式存放的。 Map 是一个双列集合 Hashtable:线程安全，速度快。底层是哈希表数据结构。是同步的。不允许null作为键，null作为值。 Properties:用于配置文件的定义和操作，使用频率非常高，同时键和值都是字符串。是集合中可以和IO技术相结合的对象。 HashMap:线程不安全，速度慢。底层也是哈希表数据结构。是不同步的。允许null作为键，null作为值。替代了Hashtable. LinkedHashMap: 可以保证HashMap集合有序。存入的顺序和取出的顺序一致。 TreeMap：可以用来对Map集合中的键进行排序. Collection是集合类的上级接口，子接口主要有Set 和List。Collections是针对集合类的一个帮助类，提供了操作集合的工具方法：一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。 《介绍Collection框架的结构；Collection 和 Collections的区别》 3.集合类框架的最佳实践有哪些根据应用的需要合理的选择集合的类型对性能非常重要 假如元素的大小是固定的，而且能事先知道，我们就该用Array而不是ArrayList. 有些集合类允许指定初始容量。因此，如果我们能估计出存储元素的数目，我们可以设置初始容量来避免重新计算hash值或者扩容. 为了类型安全，可读性和健壮性的原因总要使用翻新。同时，使用泛型还能皮面运行时的ClassCastException. 使用JDK提供的不变类（immutable class）作为Map的键可以避免为我们自己的类实现hashCode()和equals()方法。 编程的时候接口优于实现。 底层的集合实际上是空的情况下返回长度是0的集合或者是数组，不要返回null. 4.为什么 Collection 不从 Cloneable 和 Serializable 接口继承?Collection接口指定一组对象，对象即为它的元素。如何维护这些元素由Collection的具体实现决定。例如，一些如List的Collection实现允许重复的元素，而其它的如Set就不允许。很多Collection实现有一个公有的clone方法。然而，把它放到集合的所有实现中也是没有意义的。这是因为Collection是一个抽象表现。重要的是实现，克隆（cloning）或者序列化（serialization）的语义和含义是跟具体的实现相关的。因此应该由集合类的具体实现类来决定如何被克隆或者序列化。 5.说出几点 Java 中使用 Collections 的最佳实践？a）使用正确的集合类，例如，如果不需要同步列表，使用 ArrayList 而不是 Vector。b）优先使用并发集合，而不是对集合进行同步。并发集合提供更好的可扩展性。c）使用接口代表和访问集合，如使用List存储 ArrayList，使用 Map 存储 HashMap 等等。d）使用迭代器来循环集合。e）使用集合的时候使用泛型 6.Collections 中 遗留类 (HashTable、Vector) 和 现有类的区别7.什么是 B+树，B-树，列出实际的使用场景。]]></content>
      <categories>
        <category>Java Basic</category>
      </categories>
      <tags>
        <tag>Interview</tag>
        <tag>java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区块链技术栈及学习路线]]></title>
    <url>%2F2018%2F02%2F07%2F%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[仿佛一夜之间，互联网和金融圈都在谈论区块链，而区块链的发展无疑是借着数字货币之浪潮而起，而后被熟知、被认可到如今的大势所趋，目前科技与工业界的共识是区块链将会成为引领第四次工业革命的关键技术，回看2015年火爆的虚拟现实，2016年流行的大数据，2017年独领风骚的人工智能，2018年毫无疑问将会是区块链的元年，可以看到各种新技术的创新迭代正在以前所未有的速度在加快，热门技术的退潮并不是简单的历史更迭，更像是在蓄势引爆一个临界的奇点，有人如此概括：在第四次工业革命中，大数据是生产资料，人工智能是生产力，区块链就是生产关系。如此来看，不管其发展趋势如何，区块链至少是值得我们去学习和了解的。区块链的核心价值在于建立去中心、去信任、不可篡改的分布式应用场景，愿景很美好，但目前该项技术的发展还处在探索的初级阶段，预计3-5年将会大规模增长，未来10年区块链市场将趋于成熟，在区块链时代来临之前，相关技术从业者应当提前做好知识储备，搭上即将来临的顺风车。在此总结了相关学习资料和知识体系图，而目前来看一位合格区块链研发工程师所具备的技术栈应当如下： 一、比特币相关资源1.《比特币白皮书》网址浏览2.【比特币源码下载】，《比特币白皮书下载》3.《精通比特币》讲比特币很详细的一本书，看完基本对比特币的认识就清楚了。4.《TheProof-of-Work Concept》PoW机制理论介绍，英文5.《比特币的原理及运作机制》适合向圈外人介绍什么是比特币什么是区块链。6.《比特币pow难度调节机制》PoW的难度调节是一个要点，一篇简介 二、区块链1.《区块链技术指南》网页在线电子书，对区块链技术讲解得非常全面2.【csdn的blockchain知识库】3.【区块链可应用场景】应用场景探讨，布萌社区下的一篇帖子4.【汪晓明对区块链、以太坊的思考】汪晓明作为朝夕网络CEO，区块链技术的推广者和布道者，参与并制作了区块链视频节目《明说》，向开源技术大牛学习。 三、以太坊1.《以太坊白皮书英文版》2.《以太坊黄皮书》介绍以太坊原理的论文，文长慎入3.【以太坊常见问题】以上三篇都是外文资源4.【Solidity语言】Solidity语言的文档，还是英文。极客学院翻译了一档勉强凑合的doc，http://wiki.jikexueyuan.com/project/solidity-zh/7.《以太坊智能合约编程之菜鸟教程》以太坊中文网站出的8.通过truffle部署以太坊智能合约9.Truffle 3.0部署智能合约至Ethereum节点10.以太坊智能合约编写实例11.以太坊智能合约编写实例212.在CentOS6.5上搭建以太坊私有链 四、Hyperledger fabric1.《Hyperledger Fabric V1.0– 开发者快速入门》万达网络研究中心副总季宙栋写的开发者入门指南，这档知乎专栏可以订阅。2.【Hyperledger 源码分析之 Fabric】源码分析，感兴趣研究的同学可以看看3.【Hyperledgerfablic 1.0 在centos7环境下的安装与部署和动态增加节点】csdn上的一篇技术帖4.【fabric源码搭建】托管在github上的doc说明，纯英文。5.《Hyperledger Fabric1.0架构概览》6.《fabric中文文档》7.【Ubuntu中使用 Docker 部署 HyperledgerFabric】学好docker很重要 五、布萌1.布萌接入指南布萌官方的指南有些模糊，个人整理了一版出来仅供参考2.布萌API文档3.布萌SDK文档两个官方文档，其实官网就有，顺手列在这了：D4.布萌PHP SDK今天看到有朋友放出的PHP的SDK，膜拜大神 六、其他1.《Nodejs开发加密货币》基于Ebookcoin（亿书币）的开发教程，有一定参考价值2.《创建自己的私有比特币测试链》比特币私链搭建教程 最后还谈一下个人感想：现在百度搜一下区块链，培训市场的速成班广告已经占据了头条，计算了一下他们五个月左右的脱产培训班收费是2.5w上下，又是一波红利，而有些培训机构的课程体系，其实只是整合了过去的编程培训内容再添加一点区块链技术就算完事，简直一锅乱炖，这样的学习方式其实会害死人。相比商人的闻风而动，承担教育责任的大学校园却有点不作为，许多大学的计算机课程体系是远远落后的，大部分学生群体也对科技前沿和趋势动向不是很敏感，前些天看到了一篇钛媒体的报道《中国学生狂“吃鸡”，美国学生猛“挖矿”》，学习上的差距可见一斑，不论怎样，学习之事关乎己身，上士闻道勤而行之。 后续将会不断补充相关学习体系，欢迎访问我的博客站点【YitaiCloud】。部分资料参考了这篇入门到放弃，]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>区块链技术栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java关键字和操作符的总结]]></title>
    <url>%2F2018%2F02%2F04%2Fjava%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E6%93%8D%E4%BD%9C%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[final,finalize,finally关键字1.finalize和final关键字什么是finalize()方法？finalize()方法什么时候被调用？答： Java允许在类中定义一个名为finalize()的方法，一旦垃圾回收器准备好释放对象占用的存储空间，将首先调用finalize()方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。 析构函数(finalization)的目的是什么析构函数目的是撤销对象前、完成一些清理工作，比如释放资源。释放了之后这些资源可以被回收，重新利用。 final关键字有哪些用法final关键字主要用于修饰类、类成员、方法、以及方法的形参。 final修饰成员属性：说明该成员属性是常量，不能被修改； final修饰类，该类是最终类，不能被继承。 final修饰方法：该方法是最终方法，不能被重写。 final关键字修饰形参：1：当形参被修饰为final,那么该形参所属的方法中不能被篡改。 2. final 与 static 关键字可以用于哪里？它们的作用是什么？用于修饰成员变量和成员方法，可以理解为“全局常量”，对于变量表示一旦给定值就不可以修改，并且通过类名可以访问；对于方法表示不可覆盖，并且可以通过类名直接访问 3. final, finally, finalize的区别（或者说final、finalize 和 finally 的不同之处？）**final关键字可以用于类，方法，变量前，用来表示该关键字修饰的类，方法，变量具有不可变的特性。 final关键字用于基本数据类型前：这时表明该关键字修饰的变量是一个常量，在定义后该变量的值就不能被修改。 final关键字用于方法声明前：这时意味着该方法时最终方法，只能被调用，不能被覆盖，但是可以被重载。 final关键字用于类名前：此时该类被称为最终类，该类不能被其他类继承。 finalize()方法来自于java.lang.Object，用于回收资源。可以为任何一个类添加finalize方法。finalize方法将在垃圾回收器清除对象之前调用。在实际应用中，不要依赖使用该方法回收任何短缺的资源，这是因为很难知道这个方法什么时候被调用。finally，当代码抛出一个异常时，就会终止方法中剩余代码的处理，并退出这个方法的执行。finally块是程序在正常情况下或异常情况下都会运行的。比较适合用于既要处理异常又有资源释放的代码，保证了资源的合理回收。 4. 能否在运行时向 static final 类型的赋值不可以，被static final修饰的变量只能在被定义的时候或者类的静态代码块中初始化，一旦赋值后就不能在改变了。static final相当于类常量，就是在类被加载进内存的时候就要为属性分配内存，static块就是类被加载的时候执行且被执行一次，所以可以在其中进行初始化。 5. 使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变?是引用不能变（final引用恒定不变），引用的对象内容还是可以变的 8. throws, throw分别代表什么意义?throw是指的语句抛出一个异常，throws指的是声明方法可能抛出的异常类型 9、Java 有几种修饰符？分别用来修饰什么类的修饰符： public可以在其他任何类中使用，默认为统一包下的任意类。 abstract抽象类，不能被实例化，可以包含抽象方法，抽象方法没有被实现，无具体功能，只能衍生子类。 final不能被继承。 成员变量 访问修饰符： static类变量：一个类所拥有的变量，不是类的每个实例有的变量。类变量是指不管类创建了多少对象，系统仅在第一次调用类的时候为类变量分配内存，所有对象共享该类的类变量，因此可以通过类本身或者某个对象来访问类变量。 final：常量。 volatile：声明一个可能同时被并存运行的几个线程所控制和修改的变量。 abstract：只有声明部分，方法体为空，具体在子类中完成。 transient：（过度修饰符）指定该变量是系统保留，暂无特别作用的临时性变量。 方法修饰符： 访问修饰符public（公共控制符）private（私有控制符）指定此方法只能有自己类等方法访问，其他的类不能访问（包括子类）protected（保护访问控制符）指定该方法可以被它的类和子类进行访问。 final，指定该方法不能被重载。 static，指定不需要实例化就可以激活的一个方法。 synchronize，同步修饰符，在多个线程中，该修饰符用于在运行前，对他所属的方法加锁，以防止其他线程的访问，运行结束后解锁。 native，本地修饰符。指定此方法的方法体是用其他语言在程序外部编写的。 《java中的访问修饰符》《java中的类修饰符、成员变量修饰符、方法修饰符》 volatile关键字volatile是一个特殊的修饰符，只有成员变量才能使用它。在Java并发程序缺少同步类的情况下，多线程对成员变量的操作对其它线程是透明的。volatile变量可以保证下一个读取操作会在前一个写操作之后发生，就是上一题的volatile变量规则。原理以及底层实现可参考： 《面试必问的 volatile，你了解多少？》《volatile 关键字实现原理》汇编层面的讲解，推荐！ 1、volatile 修饰符的有过什么实践2、volatile 变量是什么？volatile 变量和 atomic 变量有什么不同Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。 3、volatile 类型变量提供什么保证？能使得一个非原子操作变成原子操作吗?volatile只提供了保证访问该变量时，每次都是从内存中读取最新值，并不会使用寄存器缓存该值——每次都会从内存中读取。而对该变量的修改，volatile并不提供原子性的保证。那么编译器究竟是直接修改内存的值，还是使用寄存器修改都符合volatile的定义。所以，一句话，volatile并不提供原子性的保证。 4、能创建 volatile 数组吗？可以，volatile修饰的变量如果是对象或数组之类的，其含义是对象获数组的地址具有可见性，但是数组或对象内部的成员改变不具备可见性 5、transient变量有什么特点? 一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。 transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。 被transient关键字修饰的变量不能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。 6、super什么时候使用?super主要存在于子类方法中，用于指向子类对象中父类对象。1：访问父类的属性2：访问父类的函数3：访问父类的构造函数 7、public static void 写成 static public void会怎样?一样的 8、说明一下public static void main(String args[])这段声明里每个关键字的作用?主函数是什么：主函数是一个特殊的函数，作为程序的入口，可以被jvm识别。主函数的定义： public ：代表该函数的访问权限是最大的。 static ：代表主函数随着类的加载，就已经存在了。 void： 主函数没有具体的返回值 main ： 不是关键字，是一个特殊的单词可以被jvm识别。 (String[] args) 函数的参数，参数类型是一个数组，该数组中的元素是字符串。字符串类型的数组。 主函数的格式是固定的：jvm能够识别 9、sizeof 是Java 的关键字吗?不是，C和C++用sizeof()解决移植问题，java不需要。 static关键字1、static class 与 non static class的区别 内部静态类不需要有指向外部类的引用。但非静态内部类需要持有对外部类的引用。 非静态内部类能够访问外部类的静态和非静态成员。静态类不能访问外部类的非静态成员。他只能访问外部类的静态成员。 一个非静态内部类不能脱离外部类实体被创建，一个非静态内部类可以访问外部类的数据和方法，因为他就在外部类里面。 生命周期（Lifecycle）： 静态方法（Static Method）与静态成员变量一样，属于类本身，在类装载的时候被装载到内存（Memory），不自动进行销毁，会一直存在于内存中，直到JVM关闭。 非静态方法（Non-Static Method）又叫实例化方法，属于实例对象，实例化后才会分配内存，必须通过类的实例来引用。不会常驻内存，当实例对象被JVM 回收之后，也跟着消失。 效率：静态方法的使用效率比非静态方法的效率高。 线程安全 静态方法是共享代码段，静态变量是共享数据段。既然是“共享”就有并发（Concurrence）的问题。 非静态方法是针对确定的一个对象的，所以不会存在线程安全的问题。 静态方法和实例方法是一样的，在类型第一次被使用时加载。调用的速度基本上没有差别。 2、static 关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法，静态类型有什么特点？static表示静态的意思，可用于修饰成员变量和成员函数，被静态修饰的成员函数只能访问静态成员，不可以访问非静态成员。静态是随着类的加载而加载的，因此可以直接用类进行访问。 重写是子类中的方法和子类继承的父类中的方法一样（函数名，参数，参数类型，反回值类型），但是子类中的访问权限要不低于父类中的访问权限。重写的前提是必须要继承，private修饰不支持继承，因此被私有的方法不可以被重写。在Java中，如果父类中含有一个静态方法，且在子类中也含有一个返回类型、方法名、参数列表均与之相同的静态方法，那么该子类实际上只是将父类中的该同名方法进行了隐藏，而非重写。换句话说，父类和子类中含有的其实是两个没有关系的方法，它们的行为也并不具有多态性。 《static方法能否被重写》 3、main() 方法为什么必须是静态的？能不能声明 main() 方法为非静态？用static修饰的就是静态方法。静态方法不依靠对象而存在。其直接与类有关，只要包含在类中，就可以得到执行，而不一定依附于对象的存在而执行。因此，main方法作为程序的入口方法，在这之前是不可能有任何对象被建立的，也就在main之前包括main自身不可能是非静态方法。所以main方法一定是静态的，有类就行——从而得到执行，进而有更多静态或非静态方法得到执行。 4、是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用不可以，静态函数中不能访问非静态成员变量，只能访问静态变量。因为静态优先于对象存在.静态方法中更不可以出现this 5、静态变量在什么时候加载？编译期还是运行期？静态代码块加载的时机呢？静态是随着类的加载而加载的，JVM的代码编译运行顺序是编译、类的加载到执行，属于二者的过渡期。静态代码块也是如此。 6、成员方法是否可以访问静态变量？为什么静态方法不能访问成员变量？成员方法中可以访问静态成员变量。 请看下面代码来确定程序的打印先后顺序：12345678910111213141516171819202122232425public class test &#123; public static void main(String[] args) &#123; new test(); &#125; static int num = 4; &#123; num += 3; System.out.println(b); &#125; int a = 5; &#123; System.out.println(c); &#125; test() &#123;System.out.println(d);&#125; static &#123;System.out.println(a);&#125; static void run() &#123;System.out.println(e);&#125;&#125; 执行顺序如下：1234567891011121314151617181920212223242526272829303132public class test &#123; //1.第一步，准备加载类 public static void main(String[] args) &#123; new test(); //4.第四步，new一个类，但在new之前要处理匿名代码块 &#125; static int num = 4; //2.第二步，静态变量和静态代码块的加载顺序由编写先后决定 &#123; num += 3; System.out.println(b);//5.第五步，按照顺序加载匿名代码块，代码块中有打印 &#125; int a = 5; //6.第六步，按照顺序加载变量 &#123; 成员变量第三个 System.out.println(c); //7.第七步，按照顺序打印c &#125; //如果将构造函数和构造代码块互换，依旧还是先执行构造代码块。 test() &#123; //类的构造函数，第四个加载 System.out.println(d); //8.第八步，最后加载构造函数，完成对象的建立 &#125; static &#123; //3.第三步，静态块，然后执行静态代码块，因为有输出，故打印a System.out.println(a); &#125; static void run() //静态方法，调用的时候才加载 注意看，e没有加载 &#123; System.out.println(e); &#125;&#125; 静态块（静态变量）——成员变量——构造方法——静态方法1、静态代码块（只加载一次） 2、构造方法（创建一个实例就加载一次）3、静态方法需要调用才会执行. 如果类还没有被加载： 1、先执行父类的静态代码块和静态变量初始化，并且静态代码块和静态变量的执行顺序只跟代码中出现的顺序有关。 2、执行子类的静态代码块和静态变量初始化。 3、执行父类的实例变量初始化 4、执行父类的构造函数（有构造代码块则先执行构造代码块） 5、执行子类的实例变量初始化 6、执行子类的构造函数 如果类已经被加载：则静态代码块和静态变量就不用重复执行，再创建类对象时，只执行与实例相关的变量初始化和构造方法。 补充构造代码块：给对象进行初始化。对象一建立就运行并且优先于构造函数。构造代码块和构造函数的区别，构造代码块是给所有对象进行统一初始化， 构造函数给对应的对象初始化。 switch关键字1、switch 语句中的表达式可以是什么类型数据？switch(A),括号中A的取值可以是byte、short、int、char、String，还有枚举类型。 2、switch 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上？ Java 7之前，switch后面的括号里面只能放int类型的值，注意是只能放int类型，但是放byte，short，char类型的也可以，是因为byte，short，shar可以自动提升（自动类型转换）为int，不是说就可以放它们，说白了，你放的byte，short，shar类型，然后他们会自动转换为int类型（宽化，自动转换并且安全），其实最后放的还是int类型。String可以了，但是long仍然不行。 1.小的往大的转换(宽化)，自动转换，有些时候就会自动提升为大的类型，比如switch中2.大的往小的转换(窄化)必须强制类型转换所以long不行，要想行就得强转如（int）long。同理，float、double也是不行的，要想行就强转。 3、while 循环和 do 循环有什么不同？while语法格式：123while(布尔表达式)&#123;//语句&#125; 先判断布尔表达式，如果为true就会执行循环体中的语句，然后再判断布尔表达式，如果为true就执行循环体中的语句，一直到布尔表达式为false，然后循环结束。通常用算术运算符（++ – 累减）do/while语法格式：123do&#123;//语句&#125;while(布尔表达式); 先执行一次循环体，然后在判断布尔表达式是不是true，如果是就继续执行循环体，在判断布尔表达式，直到为false就结束循环。两者的区别：while是先判断在执行如果判断不成立，就不会执行；do/while是先执行在判断，不管判断是否成立都会执行一次 操作符1、&amp;操作符和&amp;&amp;操作符有什么区别&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&amp;&amp;而不是&amp;。 2、a = a + b 与 a += b 的区别？★ =：赋值运算符，在编译器将右边的表达式结果计算出来后，和左边的变量类型比较精度，如果左边的变量精度低于右边的结果的精度，编译器会显式的报错，告诉程序员去强制转型。（若a精度类型弱于b，a = a + b出错，编译检查报错）最后将表达式的结果复制到变量所在的内存区。★ +=：暂且称之为运算符，编译器自动隐式直接将+=运算符后面的操作数强制装换为前面变量的类型，然后在变量所在的内存区上直接根据右边的操作数修改左边变量内存存储的二进制数值最后达到和赋值运算符相同的目的。与前者相比，由于后者是位操作，效率也较前者高。 3、30.1 == 0.3 将会返回什么？true 还是 false？False，类型不一致。 4、float f=3.4; 是否正确？不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成float f =3.4F;。 5、short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？对于short s1 = 1; s1 = s1 + 1;由于1是int类型，因此s1+1运算结果也是int 型，需要强制转换类型才能赋值给short型。而short s1 = 1; s1 += 1;可以正确编译，因为s1+= 1;相当于s1 = (short)(s1 + 1);其中有隐含的强制类型转换。]]></content>
      <categories>
        <category>Java Basic</category>
      </categories>
      <tags>
        <tag>Interview</tag>
        <tag>java</tag>
        <tag>关键字，操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面向对象的一些总结]]></title>
    <url>%2F2018%2F02%2F02%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88OOP%EF%BC%89%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一.面向对象的基本概念1.解释下多态性（polymorphism），封装性（encapsulation），内聚（cohesion）以及耦合（coupling）抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。 封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情）。内聚：进行架构设计时的内聚高低是指，设计某个模块或者关注点时，模块或关注点内部的一系列相关功能的相关程度的高低。高内聚提供了更好的可维护性和可复用性。而低内聚的模块则表名模块直接的依赖程度高，那么一旦修改了该模块依赖的对象则无法使用该模块，必须也进行相应的修改才可以继续使用。 耦合：简单地说，软件工程中对象之间的耦合度就是对象之间的依赖性。指导使用和维护对象的主要问题是对象之间的多重依赖性。对象之间的耦合越高，维护成本越高。因此对象的设计应使类和构件之间的耦合最小。耦合性是程序结构中各个模块之间相互关联的度量。它取决于各个模块之间的接口的复杂程度、调用模块的方式以及哪些信息通过接口。 耦合可以分为以下几种，它们之间的耦合度由高到低排列如下： 内容耦合。当一个模块直接修改或操作另一个模块的数据时，或一个模块不通过正常入口而转入另一个模块时，这样的耦合被称为内容耦合。内容耦合是最高程度的耦合，应该避免使用之。 公共耦合。两个或两个以上的模块共同引用一个全局数据项，这种耦合被称为公共耦合。在具有大量公共耦合的结构中，确定究竟是哪个模块给全局变量赋了一个特定的值是十分困难的。 外部耦合 。一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传递该全局变量的信息，则称之为外部耦合。控制耦合 。一个模块通过接口向另一个模块传递一个控制信号，接受信号的模块根据信号值而进行适当的动作，这种耦合被称为控制耦合。标记耦合 。若一个模块A通过接口向两个模块B和C传递一个公共参数，那么称模块B和C之间存在一个标记耦合。 数据耦合。模块之间通过参数来传递数据，那么被称为数据耦合。数据耦合是最低的一种耦合形式，系统中一般都存在这种类型的耦合，因为为了完成一些有意义的功能，往往需要将某些模块的输出数据作为另一些模块的输入数据。 非直接耦合 。两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的。 参考：《面向对象三大特性五大原则 + 低耦合高内聚》 2.多态的用途和实现原理 1、编译时多态（又称静态多态）2、运行时多态（又称动态多态） 重载（overload）就是编译时多态的一个例子，编译时多态在编译时就已经确定，运行时运行的时候调用的是确定的方法。我们通常所说的多态指的都是运行时多态，也就是编译时不确定究竟调用哪个具体方法，一直延迟到运行时才能确定。这也是为什么有时候多态方法又被称为延迟方法的原因。 多态通常有两种实现方法：1、子类继承父类（extends）2、子类实现接口（implements） 多态最大的用途个人认为在于对设计和架构的复用，更进一步来说，《设计模式》中提倡的针对接口编程而不是针对实现编程就是充分利用多态的典型例子。定义功能和组件时定义接口，实现可以留到之后的流程中。同时一个接口可以有多个实现，甚至于完全可以在一个设计中同时使用一个接口的多种实现。 多态实现原理多态允许具体访问时实现方法的动态绑定。Java对于动态绑定的实现主要依赖于方法表，通过继承和接口的多态实现有所不同。继承：在执行某个方法时，在方法区中找到该类的方法表，再确认该方法在方法表中的偏移量，找到该方法后如果被重写则直接调用，否则认为没有重写父类该方法，这时会按照继承关系搜索父类的方法表中该偏移量对应的方法。接口：Java 允许一个类实现多个接口，从某种意义上来说相当于多继承，这样同一个接口的的方法在不同类方法表中的位置就可能不一样了。所以不能通过偏移量的方法，而是通过搜索完整的方法表。tips：因为每次接口调用都要搜索方法表，所以从效率上来说，接口方法的调用总是慢于类方法的调用的。 《Java 多态的实现机制》《Java技术——多态的实现原理》 3.对象封装的原则是什么?在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。要访问该类的代码和数据，必须通过严格的接口控制。封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。 修改属性的可见性来限制对属性的访问（一般限制为private）； 对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问； 4.获得一个类的类对象有哪些方式？ 1.通过对象的getClass方法进行获取。这种方式需要具体的类和该类的对象，以及调用getClass方法。 2.任何数据类型(包括基本数据类型)都具备着一个静态的属性class，通过它可直接获取到该类型对应的Class对象。这种方式要使用具体的类，然后调用类中的静态属性class完成，无需调用方法，性能更好。 3.通过Class.forName()方法获取。这种方式仅需使用类名，就可以获取该类的Class对象，更有利于扩展。1234567891011121314151617181920212223242526272829303132333435363738import org.junit.Test;/** * 演示获取Class c对象的三种方法 *@fileName ReflectGetClass.java */public class ReflectGetClass &#123; /** * 法1：通过对象---对象.getClass()来获取c(一个Class对象) */ @Test public void get1()&#123; Person p=new Person("Jack", 23); Class c=p.getClass();//来自Object方法 &#125; /** * 法2：通过类(类型)---任何数据类型包括(基本数据类型) * 都有一个静态的属性class ，他就是c 一个Class对象 */ @Test public void get2()&#123; Class c=Person.class; Class c2=int.class; &#125; /** * 法3：通过字符串(类全名 )---能够实现解耦：Class.forName(str) */ @Test public void get3()&#123; try &#123; Class c=Class.forName("cn.hncu.reflect.test.Person"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 5.重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？一、重写（override）override是重写（覆盖）了一个方法，以实现不同的功能。一般是用于子类在继承父类时，重写（重新实现）父类中的方法。重写（覆盖）的规则： 1、重写方法的参数列表必须完全与被重写的方法的相同,否则不能称其为重写而是重载. 2、重写方法的访问修饰符一定要大于被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private）。 3、重写的方法的返回值必须和被重写的方法的返回一致； 4、重写的方法所抛出的异常必须和被重写方法的所抛出的异常一致，或者是其子类； 5、被重写的方法不能为private，否则在其子类中只是新定义了一个方法，并没s有对其进行重写。 6、静态方法不能被重写为非静态的方法（会编译出错）。二、overload是重载一般是用于在一个类内实现若干重载的方法，这些方法的名称相同而参数形式不同。重载的规则： 1、在使用重载时只能通过相同的方法名、不同的参数形式实现。不同的参数类型可以是不同的参数类型，不同的参数个数，不同的参数顺序（参数类型必须不一样）； 2、不能通过访问权限、返回类型、抛出的异常进行重载； 3、方法的异常类型和数目不会对重载造成影响；多态的概念比较复杂，有多种意义的多态，一个有趣但不严谨的说法是：继承是子类使用父类的方法，而多态则是父类使用子类的方法。一般，我们使用多态是为了避免在父类里大量重载引起代码臃肿且难于维护。《java编程思想》中很好的回答了不能以返回值来区分重载方法：12void f()&#123; &#125;void f()&#123; return 1; &#125; 假如有int x=f(),这里是可以区分重载方法，但有时候并不需要返回值，只是调用方法，那么像这样的f()就让人无法理解了。 6.说出几条 Java 中方法重载的最佳实践？** a）不要重载这样的方法：一个方法接收 int 参数，而另个方法接收 Integer 参数。 b）不要重载参数数量一致，而只是参数顺序不同的方法。 c）如果重载的方法参数个数多于 5 个，采用可变参数。 二、抽象类和接口1.抽象类和接口的区别 一、相似性 接口和抽象类都不能被实例化，它们都位于继承树的顶端，用于被其他类实现和继承。 接口和抽象类都可以包含抽象方法，实现接口或继承抽象类的普通子类都必须实现这些抽象方法。二、接口和抽象类的区别 接口里只能包含抽象方法，静态方法和默认方法，不能为普通方法提供方法实现，抽象类则完全可以包含普通方法。 接口里只能定义静态常量，不能定义普通成员变量，抽象类里则既可以定义普通成员变量，也可以定义静态常量。 接口不能包含构造器，抽象类可以包含构造器，抽象类里的构造器并不是用于创建对象，而是让其子类调用这些构造器来完成属于抽象类的初始化操作。 接口里不能包含初始化块，但抽象类里完全可以包含初始化块。 一个类最多只能有一个直接父类，包括抽象类，但一个类可以直接实现多个接口，通过实现多个接口可以弥补Java单继承不足。 接口可以继承接口。抽象类可以实现(implements)接口抽象类可继承具体类。抽象类中可以有静态的main方法。 备注：只要明白了接口和抽象类的本质和作用，这些问题都很好回答，你想想，如果你是java语言的设计者，你是否会提供这样的支持，如果不提供的话，有什么理由吗？如果你没有道理不提供，那答案就是肯定的了。只有记住抽象类与普通类的唯一区别就是不能创建实例对象和允许有abstract方法。 2.java接口的基本概念，是否可继承，以及优点？接口（Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合。接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。如果一个类只由抽象方法和全局常量组成，那么这种情况下不会将其定义为一个抽象类。只会定义为一个接口，所以接口严格的来讲属于一个特殊的类，而这个类里面只有抽象方法和全局常量，就连构造方法也没有。 一个接口可以继承多个接口.interface C extends A, B {}是可以的. 一个类可以实现多个接口:class D implements A,B,C{} 但是一个类只能继承一个类,不能继承多个类class B extends A{} 在继承类的同时,也可以继承接口:class E extends D implements A,B,C{}这也正是选择用接口而不是抽象类的原因 3、接口的优点或者说面向接口编程的思想是什么（这里要结合运行时多态更好理解）在系统分析和架构中，分清层次和依赖关系，每个层次不是直接向其上层提供服务（即不是直接实例化在上层中），而是通过定义一组接口，仅向上层暴露其接口功能，上层对于下层仅仅是接口依赖，而不依赖具体类。好处：首先对系统灵活性大有好处。当下层需要改变时，只要接口及接口功能不变，则上层不用做任何修改。甚至可以在不改动上层代码时将下层整个替换掉。接口体现的是一种规范和实现分离的设计哲学，充分利用接口可以极好地降低程序各模块之间的耦合，从而提高系统的可扩展性和可维护性。基于这种原则，通常推荐“面向接口”编程，而不是面向实现类编程，希望通过面向接口编程来降低程序的耦合。总的来说就是：降低程序耦合度，提高系统的可扩展性和维护性。 三、继承1、继承（Inheritance）与聚合（Aggregation）的区别在哪里2、继承和组合之间有什么不同 如果存在一种IS-A的关系（比如Bee“是一个”Insect），并且一个类需要向另一个类暴露所有的方法接口，那么更应该用继承的机制。 如果存在一种HAS-A的关系（比如Bee“有一个”attack功能），那么更应该运用组合。 3、为什么类只能单继承，接口可以多继承首先，类的多继承有缺点：第一，如果一个类继承多个父类，如果父类中的方法名如果相同，那么就会产生歧义。第二，如果父类中的方法同名，子类中没有覆盖，同样会产生上面的错误。但是接口就设计成多继承，是因为接口可以避免上述问题：首先，接口中的只有抽象方法和静态常量。对于一个类实现多个接口的情况和一个接口继承多个接口的情况，因为接口只有抽象方法，具体方法只能由实现接口的类实现（也是因为实现类一定会覆盖接口中的方法），在调用的时候始终只会调用实现类（也就是子类覆盖的方法）的方法（不存在歧义），因此不存在 多继承的第二个缺点；而又因为接口只有静态的常量，但是由于静态变量是在编译期决定调用关系的，即使存在一定的冲突也会在编译时提示出错；而引用静态变量一般直接使用类名或接口名，从而避免产生歧义，因此也不存在多继承的第一个缺点。4、存在两个类，C 继承 B，B 继承 A，能将 B 转换为 C 么？如 C = (C) B不能转换，测试代码报错：Exception in thread &quot;main&quot; java.lang.ClassCastException: interfaceDemo.B cannot be cast to interfaceDemo.C 5、如果类 a 继承类 b，实现接口c，而类 b 和接口 c 中定义了同名变量，请问会出现什么问题 四、泛型1、泛型的存在是用来解决什么问题？首先需要明确泛型的概念，泛型（Generics ）是把类型参数化，运用于类、接口、方法中，可以通过执行泛型类型调用 分配一个类型，将用分配的具体类型替换泛型类型。然后，所分配的类型将用于限制容器内使用的值，这样就无需进行类型转换，还可以在编译时提供更强的类型检查。总结来说就是：（1）消除显示的强制类型转换，提高代码复用（2）提供更强的类型检查，避免运行时的ClassCastException。这个问题产生的背景是针对容器中，基于继承的泛型实现会带来两个问题，请看代码：123456public class ArrayList &#123; public Object get(int i) &#123; ... &#125; public void add(Object o) &#123; ... &#125; ... private Object[] elementData;&#125; 基于继承的泛型实现会带来两个问题：第一个问题是有关get()方法的，我们每次调用get()方法都会返回一个Object对象，每一次都要强制类型转换为我们需要的类型，这样会显得很麻烦；第二个问题是有关add方法的，假如我们往聚合了String对象的ArrayList中加入一个File对象，编译器不会产生任何错误提示，而这不是我们想要的。所以，从Java 5开始，ArrayList在使用时可以加上一个类型参数（type parameter），这个类型参数用来指明ArrayList中的元素类型。类型参数的引入解决了以上提到的两个问题，如以下代码所示：1234ArrayList&lt;String&gt; s = new ArrayList&lt;String&gt;();s.add("abc");String s = s.get(0); //无需进行强制转换s.add(123); //编译错误，只能向其中添加String对象 2、泛型的常用特点？这里其实问的就是泛型在使用过程中遵循的相关规范。类型参数（又称类型变量）用作占位符，指示在运行时为类分配类型。根据需要，可能有一个或多个类型参数，并且可以用于整个类。根据惯例，类型参数是单个大写字母，该字母用于指示所定义的参数类型。下面列出每个用例的标准类型参数：1234567E：元素K：键N：数字T：类型V：值S、U、V 等：多参数情况中的第 2、3、4 个类型? 表示不确定的java类型（无限制通配符类型） 《Java 泛型一览笔录》《深入理解Java之泛型》 五、匿名内部类内部类（nested classes），面向对象程序设计中，可以在一个类的内部定义另一个类。嵌套类分为两种，即静态嵌套类和非静态嵌套类。静态嵌套类使用很少，最重要的是非静态嵌套类，也即是被称作为内部类(inner)。内部类是JAVA语言的主要附加部分。内部类几乎可以处于一个类内部任何位置，可以与实例变量处于同一级，或处于方法之内，甚至是一个表达式的一部分。 1、匿名内部类是否可以继承其它类？是否可以实现接口？使用匿名内部类我们必须要继承一个父类或者实现一个接口，当然也仅能只继承一个父类或者实现一个接口。同时它也是没有class关键字，这是因为匿名内部类是直接使用new来生成一个对象的引用，当然这个引用是隐式的。不可以继承其它类和实现接口。 2、内部类分为几种？ 成员内部类，在一个类（外部类）中直接定义的内部类； 局部内部类，在一个方法（外部类的方法）中定义的内部类; 匿名内部类， 1.成员内部类可以访问它的外部类的所有成员变量和方法，不管是静态的还是非静态的都可以。在外部类里面创建成员内部类的实例：this.new B()；在外部类之外创建内部类的实例：(new Test1()).new B().go();2.局部内部类定义在方法中，比方法的范围还小。是内部类中最少用到的一种类型。像局部变量一样，不能被public,protected, private和static修饰。只能访问方法中定义的final类型的局部变量。方法内部类在方法中定义，所以只能在方法中使用，即只能在方法当中生成方法内部类的实例并且调用其方法。3.匿名内部类没有名字的局部内部类，不使用关键字class, extends, implements, 没有构造方法。什么情况下需要使用匿名内部类？如果满足下面的一些条件，使用匿名内部类是比较合适的： 只用到类的一个实例。 类在定义后马上用到。 类非常小（SUN推荐是在4行代码以下） 给类命名并不会导致你的代码更容易被理解。 在使用匿名内部类时，要记住以下几个原则： 匿名内部类不能有构造方法。 匿名内部类不能定义任何静态成员、方法和类。 匿名内部类不能是public,protected,private,static。 只能创建匿名内部类的一个实例。 一个匿名内部类一定是在new的后面，用其隐含实现一个接口或实现一个类。 因匿名内部类为局部内部类，所以局部内部类的所有限制都对其生效。123456789101112131415161718//实例代码interface innerclass&#123; public void print();&#125;public class Main &#123; public static void main(String[] args) &#123; innerclass i = new innerclass() &#123; @Override public void print() &#123; System.out.println("匿名内部类"); // TODO Auto-generated method stub &#125; &#125;; i.print(); &#125;&#125; 匿名内部类的高频使用场景是在多线程下(灵活使用箭头函数语法糖)：12345678910// Java 8之前：new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println("Before Java8, too much code for too little to do"); &#125;&#125;).start();//Java 8方式：new Thread(() -&gt; System.out.println("In Java8, Lambda expression!!") ).start(); 3、内部类可以引用它的包含类（外部类）的成员吗？内部类可以直接访问外部类的成员属性 4、请说一下 Java 中为什么要引入内部类？还有匿名内部类？ 内部类对象可以访问创建它的对象的实现，包括私有数据； 内部类不为同一包的其他类所见，具有很好的封装性； 使用内部类可以很方便的编写事件驱动程序； 匿名内部类可以方便的定义运行时回调； 内部类可以方便的定义]]></content>
      <categories>
        <category>Java Basic</category>
      </categories>
      <tags>
        <tag>Interview</tag>
        <tag>java</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
</search>
